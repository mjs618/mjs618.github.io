<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码老中医</title>
  
  <subtitle>一个专注技术的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-04T14:49:09.953Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Maojinsong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/11/04/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/04/学习算法/</id>
    <published>2019-11-04T14:48:53.160Z</published>
    <updated>2019-11-04T14:49:09.953Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>此文对我影响很大，分享出来给大家，愿大家早日成为大神。</p><p>1）不要完美主义！<br>我观察到的大多数同学犯得最最最最大的“错误”，就是在学习上“完美主义”。乃至后续很多其他的问题，在我看来都和这个问题是直接相关的。</p><p>举个最经典的例子，也是我经常举的例子，背英语单词（在这里我们先不聊背英语单词是不是好的英语学习方法，我们只看如果我们想要背英语单词的话，应该怎么背）。</p><p>我发现很多同学拿着红宝书，第一个list都没翻过去就放弃了。这是因为每天背完第一个 list 以后，第二天会发现：第一个list还是有很多单词没掌握，然后就继续背第一个 list。然后一周后，发现自己第一个 list 都搞不定，觉得英语好难，彻底放弃了。这就是“完美主义”：不把第一个 list “彻底”掌握不肯继续前进。这样是不对的。背了一个list，能多记一个词，都是进步。就算一个词都没记住，模糊有了印象，也是一种进步。</p><p>我们不应该过度着眼于我们还不够完美。</p><p>学习不是要么 0 分，要么 100 分的。80 分是收获；60 分是收获；20 分也是收获。有收获最重要。但是因为着眼于自己的不完美，最终放弃了，那就是彻底的 0 分了。</p><p>仔细想，这种“完美主义害死人”的例子特别多。我看到过很多同学，其实是在学习的路上，被自己的“完美主义”逼得“放弃了”——由于学习中有一点没有做好，遭受到了一点点挫折，最终就放弃了整个学习计划。每个人都一定要接受自己的不完美。想开一点：我们都不是小升初考了满分，才能上初中的；也不是中考考了满分，才能读高中的；更不是高考考了满分，才能念大学的；将来也不会是大学所有科目都是满分，才能出来工作。不完美其实是常态，根本不会影响我们学习更多更深入的内容。但是在自学过程中，很多同学却要求自己在自己制定的每一步计划中都达到“完美”，才进行下一步。最终结果，通常都是“放弃”：（</p><p>可能有的同学会跳出来反驳我：学习当然要认真啊！在这里，我必须强调，我所说的“不要完美主义”，和“学习认真”是不冲突的。</p><p>什么是“完美主义”，什么又是“囫囵吞枣”，这是一个“度”，每个人其实不一样。不要“完美主义”，不代表学习可以草率前行。</p><p>每个人都必须要找到适合自己的学习节奏。我的经验是：在一些情况下，问自己一句：是不是自己又犯“完美主义”的毛病了：）</p><p>2）不要过度“学习路径依赖”，学习要冲着自己的目标去。<br>什么意思？就是现在信息太发达了，对于大多数领域的知识，网上会有很多所谓的“学习路径”。我不是说这些学习路径没有用，但是不能“过度”依赖这些所谓的学习路径。</p><p>比如，很多同学想学机器学习，大多数学习路径都会告诉你，机器学习需要数学基础。于是，很多同学就转而学习数学去了，非要先把数学学好再去学机器学习。可是发现数学怎么也学不好（在这里，可能完美主义的毛病又犯了），而机器学习却一点儿都没学。最终放弃了机器学习，非常可惜。</p><p>其实，如果真正去接触机器学习，就会发现，至少在入门阶段，机器学习对数学的要求没有那么高。正因为如此，我一直建议：只要你在本科接触过高数，线数，概率这些科目的基础概念，想学机器学习，就去直接学习机器学习。学习过程中发现自己的数学不够用，再回头补数学。在这种情况下，数学学习得也更有目标性，其实效果更好。</p><p>类似这样的例子还有很多，很多同学想学习做 iOS app，就先去精通 Swift 语言，或者想做android app，就先去精通 java 语言。在我看来大可不必。以我的经验，只要你有一门编译型语言基础，大概看一下这些语言的基础语法，就可以直接上手 iOS 或者 android app 的开发了。先能做出一个最基本的 app，在这个过程中，就会意识到语言特性的意义，再回头深入研究语言也不迟。此时还能结合真实的开发任务去理解语言特性，比没有上手 app 开发，抽象地理解语言特性，有意义的多。</p><p>虽然我一再强调对预算法的学习，语言不重要，但还是有很多同学表示，要先把 C++ 学透，再回来把课程中的算法学好。这是完全没必要的。事实上，在我的这两门课程中，我看到的收获最大的同学，是那些能够把课程中的算法思想理解清楚，然后用自己熟悉的语言去实现的同学：）</p><p>依然是：不要“过度”学习路径依赖，什么叫“过度”，每个人的标准不一样。每个人都需要寻找自己的那个“度”。</p><p>3） 不要迷信权威的“好”教材。<br>不是说权威教材不好，而是每一本教材都有其预设的读者群，如果你不在这个预设的读者群的范畴里，教材再好也没用。最简单的例子：再好的高数教材，对于小学生来说，都是一堆废纸。</p><p>我经常举的一个例子是《算法导论》。我个人建议如果你是研究生或者博士生，已经有了一定的算法底子，才应该去阅读《算法导论》，我在我的课程的问答区，也谈过如何学习使用算法导论。</p><p>但是对大多数本科同学，尤其是第一次接触算法的同学，《算法导论》实在不是一个好的教材。</p><p>但很可惜，很多同学在学习中有上面的两个毛病，既过度路径依赖，别人说《算法导论》好，学习算法要走学《算法导论》这个路径，自己就不探索其他更适合自己的学习路径了，一头扎进《算法导论》里；同时还“完美主义”，对于《算法导论》的前几章，学习的事无巨细，但其实接触了很多在初学算法时没必要学习的内容。最后终于觉得自己学不下去了，放弃了对“算法”整个学科的学习。认为算法太难了。</p><p>诚然，算法不容易，但是，一上来就抱着《算法导论》啃，实在是选择了一条完全没必要的，更难的，甚至可能是根本走不通的路。对于一个领域的学习，了解市面上有什么好的教材是必要的，单也不能迷信权威教材。每个人必须要去探索学习如何寻找适合自己的学习材料。</p><p>4）不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。<br>很多同学问我最初学习算法的是什么教材，我告诉他们是这本教材：《算法设计与分析基础》 。在这里，我完全没有推荐这本教材的意思。事实上，现在我有点儿“鄙视”这本教材。因为我在学习它的过程中，发现这本教材有很多错误（帮助它纠正错误其实也提高了我的水平：）</p><p>当然，现在这本书的版本可能也和我当时学习的版本不同了，大部分错误应该已经纠正了。）但它确实是我的一本很重要的算法启蒙教材。</p><p>关键原因是，它够薄。</p><p>在大多数时候，如果有人问我教材推荐，基本上我的回答都是，如果是入门水平：随便找一本在京东，亚马逊，豆瓣上，评分不太差的“薄”的教材，就 ok 了。</p><p>在这里，关键字是够“薄”。</p><p>因为“薄”的教材能让你以最快的速度看完，对整个学科有一个全盘的认识：这个领域是做什么的？解决什么问题了？整体解决问题的思路是怎样？解决问题的方法大致是怎样划分的？一些最基础的方法具体是怎样的。这些在初学阶段是至关重要！是让你全盘把握整个领域脉络的。</p><p>虽然通过这么一本薄薄的教材，你的脉络把握肯定不够全面细致，但比没有强太多！我看过不少同学，一上来学习《算法导论》，关于复杂度分析的笔记做了好几页，然后就放弃了，可是连什么是动态规划都不知道。这样完全没有对“算法”这个领域有全面的认识，甚至可以说根本没有学过“算法”！</p><p>先用薄教材入门，再找“厚”教材，细细体会其中的细节，是我百试不爽的学习方法。</p><p>另外，在这里，我还要强调“入门教材”，很多教材虽然够“薄”，但不是“入门教材”。大家要注意。</p><p>5）不要迷信单一教材。<br>很多同学理解了要找“薄”教材入门的道理，却还是非要我推荐一本具体的“薄”教材，说实话，很多时候这让我有点儿哭笑不得。</p><p>因为我随便推荐一本，我确实不敢保证它是“最好的”，“最适合你的”，但是各个领域那么多教材，我又不可能都一一看过，一一比较过。</p><p>最最重要的是，我的学习经验告诉我，在大多数情况下，学习不是一本固定教材可以搞定的。</p><p>非要找到一本“最适合自己的”教材，然后就一头扎进去，其实是不科学的。我印象很深刻，我读本科的时候，那会儿申请了一个项目，要做一个网站（那时候服务端都用 ASP.NET ），我一口气从图书馆借了 10 本 ASP.NET 的教材，然后以一本最薄的书为主干去看，发现这本书介绍不清楚的概念，马上就从其他书里找答案。</p><p>通常不同的作者对同一个事物从不同的角度做解读，是能够帮助你更深刻的认识一个概念的。基本上一个月的时间，我就从一个完全的网站搭建小白，做出了这个项目需要的那个网站。</p><p>这个习惯我一直延续，研究生的时候，对什么领域感兴趣了，第一件事就是到图书馆，借十本相关书籍回来翻看。</p><p>但是，大多数同学喜欢仅仅扎进一本书里，一旦选定了自己的学习材料，就对其他材料充耳不闻，甚至是排斥的心理。这种做法，一方面又是“完美主义”的表现——非要把这本教材学透；另一方面，其实也是“犯懒”的表现，不愿意多翻翻，多看看，自己多比较比较，自己去寻找最适合自己的材料，一味地盲目相信所谓“大神”的推荐，殊不知，这些推荐，不一定是更适合自己的材料；更何况，还有很多大神，明明是靠不出名的“薄”教材入的门，但给别人做推荐的时候，就突然变成自己是算法奇才，自幼阅读《算法导论》而所成的神话了：）</p><p>6）实践<br>前面说了很多和教材选择相关的话题，但对于计算机领域的学习来说，教材的意义其实远远小于实践的意义。如果仅仅是看学习材料就是学习的话，那么慕课网的视频后期处理人员就是水平最高的工程师了。因为每段视频，他们都需要看一遍。但是，很显然，仅仅是看视频，是无法学到知识的。</p><p>对于计算机领域的学习来说，真正动手实践去编程是异常重要的。怎么夸大其中的作用都不过分。</p><p>这就好比学游泳，必须下水去游泳；或者学开车，必须亲自上路。</p><p>否则你说的再头头是道，一个小学生文化水平的人，只要他开过车，游过泳，都能在这两个领域瞬间秒杀你。</p><p>很多同学都说我的算法讲得好，其实，我一直认为，这其中的一个最简单的秘诀就是：我带领大家把大多数算法都非常细致的实现了一遍；或者对其中的应用进行了非常具体的实践。</p><p>反观大多数高校教育，对于算法或者机器学习这种一定程度偏理论的学习，通常非常不强调实践。最终的结果是学习者只是接受了很多抽象的概念，但对其中具体的实现细节，却是云里雾里。</p><p>我见过太多同学，都明白什么是 O(n^2) 复杂度，什么是 O(nlogn) 的复杂度，却问我对于 100 万的数据规模，为什么自己的选择排序运行起来就没反应了。答案很简单：O(n^2) 的复杂度太慢了，100 万的数据规模太大了，一般家用计算机转选择排序一时半会儿是转不完的。这些同学一定理解 O(n^2) 的算法比 O(nlogn) 的算法慢，却没有真正实践过，不知道这个差距到底是多少。</p><p>在我的课程中，经常遇到有些同学提出这样的问题：这个算法的某句话（或者某段逻辑），为什么要写成 A 的样子，而不是 B 的样子？这种问题其实很好，但我觉得解决方法也很简单，实际的去把算法改写成 B 的样子，实际的运行试试看，看会发生什么。如果发生了错误，仔细分析一下，为什么会有错误？如果没有错误，具体比较一下：A和B两种不同的写法，为什么都正确？又有什么区别？</p><p>真正的学习上的提高，就发生在这个过程中。</p><p>我当然可以告诉给同学们一个结果，但是自己亲自实践一遍，相比阅读我给出的一个答案，自己对其中问题理解的深刻程度，是完全不可比拟的。</p><p>7）debug非常非常重要。<br>我看到的另一类“经典”问题就是：老师，这个代码为什么错了，然后贴一大段代码。这种问题背后，依然是，透露着学习方法的不对劲：提问的同学懒得 debug 。</p><p>在计算机领域，debug 近乎和实践是一个意思。如果只是把材料上的代码“抄”一遍，这不叫实践，这叫抄代码。小学生也能做。但是“抄”一遍，不小心没抄对，发生了错误，然后自己一点一点调试，找到错误的根源，这叫真的实践。小学生不能做。（当然，我更推崇的是：自己理解了算法的逻辑，按照自己的理解，把算法写出来：）</p><p>不过很多同学不喜欢 debug，我当然理解。其实谁都不喜欢 debug ，但是，debug 才是最重要的能力。（通常在一个领域里，你最不喜欢做的事情，就是这个领域的核心竞争力：）是计算机领域异常重要的一项技能。我见过的所有计算机领域的“高手”，不管是在哪个细分领域，都无一例外，是个 debug 好手。我经常告诉大家，在实际工作中，其实 debug 的时间要占你真正编程时间的 70%。如果你做一个项目，根本不需要 debug ，要么是你的项目对你来说太简单了，要么是你根本没有接触到这个项目的核心。</p><p>debug 不仅仅是找到代码错误，解决错误的手段，其实更是一个重要的学习手段。通过 debug，看看自己写的程序执行逻辑，哪里和自己设想的不一致？再回头看自己哪里想错了，或者想漏了，分析一下自己为什么想错了，或者想漏了，等等等等，依然是，进步就是发生在这个过程的。</p><p>在我的算法课程中，很多同学对递归想不明白，我的建议都是：用一个小数据量，一步步跟踪程序，看看程序到底是怎么运行的。通常这么做，1 个小时的时间，就足以让你深刻理解递归程序的运转逻辑。可是，很多同学懒得花这1个小时的时间，最终的结果是，花了一个下午，对着代码生看，硬想，最终还是没有理解程序的运转逻辑。</p><p>8）量变到质变。<br>还有很多同学，对于算法的一些问题，会问：老师，你是怎么想到用这样的方法的？对于这类问题，我的回答一般都是：你见的还不够多。</p><p>不知道是不是受高中阶段学习的影响，有一些同学特别执着于就着一个单一的问题，寻找其中的“解题路径”。当然，我不是说这是完全错误的，但也有一个“度”。</p><p>我的经验是：与其把时间花在这里，不如去见更多问题。</p><p>比如动态规划，是算法学习的一个难点，很多同学在学会了背包问题的解法之后，总是执着于去追寻：是怎么想到这种状态定义的方法的。可能是我个人水平有限，我无法清楚地解释是如何想到这种状态定义的方法的。但是我的经验告诉我：再去看，去实践 100 个动态规划相关的问题，然后回头看背包问题，你会发现这种状态定义的方式非常自然。</p><p>仅仅对着一个问题思考，很多时候都是死胡同。你见识的还不够多，就不足以帮助你总结出更加“普遍”的问题解决的规律。当你见得足够多的时候，一切就都变得很自然，所谓的“量变到质变”。</p><p>不过，大多数同学在这个环节都会“犯懒”，企图通过一个问题就理解问题的本质，这其实和企图通过一本教材就精通一个领域的想法是一样的，是不现实的，不可能的。同时，这里又包含着学习过程中的“完美主义”的思想，遇到一个问题一定要把它想的无比透彻。但是我的经验告诉我：大多数问题，其实都是需要“回头看”的。随着你对一个领域理解的越深入，回头再去看那些曾经的问题，都会产生新的视角，对于很多曾经想不明白的问题也豁然开朗。这也是“进步”的根源。如果卡在一个问题上不前进，不给自己“回头看”的机会，甚至最后是放弃了，就什么也没有学会了。</p><p>所以，很多时候，你发现对一些问题“百思不得其解”，或许不是因为自己“笨”，而是因为“还不够努力”：）</p><p>9）最后，一定要相信时间的力量。<br>有一天，在我的一个算法课程群里，有个滴滴的后端大神发招聘，结果大家七嘴八舌的就议论开了，大致主题思想就是：自己什么时候能够成为滴滴的后端大神。这位滴滴的后端大神今年 32 岁；大多数议论的同学，其实连 22 岁都不到。我告诉他们，其实 10 年后，你们就是大神。</p><p>这其实很好理解，回想十年前，也就是 12 岁的你，和现在的你比较，是不是天壤之别？如果把你扔到一堆 12 岁的小朋友中间，22 岁的你是不是就是个大神？同理，32 岁的人，已经在业界摸爬滚打了那么多年，扔回到22岁的大学生中间，当然是大神：）</p><p>很多时候，所谓的“大神”并不神秘，很多时候，仔细观察，会发现时间有着不可磨灭的作用。只要你没有虚度时间，每天都在进步，通常结果都不会太差的。如果再加上一点点机遇，可能就不仅仅是大神。</p><p>愿大家也早日成为大神。</p><p>End<br>本文作者为 liuyubobobo，算法大牛，ACM亚洲区奖牌获得者，现居美国，创业者。bobo老师对我影响极大，我的算法入门和进阶都是靠他的指导，希望此篇文章对大家有帮助~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言&lt;br&gt;此文对我影响很大，分享出来给大家，愿大家早日成为大神。&lt;/p&gt;
&lt;p&gt;1）不要完美主义！&lt;br&gt;我观察到的大多数同学犯得最最最最大的“错误”，就是在学习上“完美主义”。乃至后续很多其他的问题，在我看来都和这个问题是直接相关的。&lt;/p&gt;
&lt;p&gt;举个最经典的例子，也
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题集</title>
    <link href="http://yoursite.com/2019/11/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>http://yoursite.com/2019/11/03/面试题集/</id>
    <published>2019-11-03T13:13:50.000Z</published>
    <updated>2019-11-03T07:30:55.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019秋招几个月累积的知识点，东西太多，懒得重整理做索引，尽量用(<em>)和*</em>加粗**标注出高频知识点, 都是面试问过的或笔试考过的</p></blockquote><p><strong>Java基础知识(*)</strong></p><ul><li><a href="https://blog.csdn.net/qq_16633405/article/details/79211002" target="_blank" rel="noopener">https://blog.csdn.net/qq_16633405/article/details/79211002</a></li></ul><p><strong>Spring Boot 启动 流程(*)</strong></p><ul><li><a href="https://juejin.im/post/5b679fbc5188251aad213110#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5b679fbc5188251aad213110#heading-0</a></li></ul><p><strong>Spring 一些面试题(*)</strong></p><ul><li><a href="https://www.ctolib.com/topics-35589.html" target="_blank" rel="noopener">https://www.ctolib.com/topics-35589.html</a></li></ul><p><strong>匿名内部类编译class(*)</strong></p><ul><li><a href="https://blog.csdn.net/lazyer_dog/article/details/50669473" target="_blank" rel="noopener">https://blog.csdn.net/lazyer_dog/article/details/50669473</a></li></ul><p><strong>为什么集合类没有实现Cloneable和Serializable接口？</strong></p><ul><li><a href="https://www.nowcoder.com/questionTerminal/2a4902f67d5b49b6b4c05f9d7e422caf" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/2a4902f67d5b49b6b4c05f9d7e422caf</a></li></ul><p><strong>自动装箱原理</strong></p><ul><li><a href="https://www.jianshu.com/p/0ce2279c5691" target="_blank" rel="noopener">https://www.jianshu.com/p/0ce2279c5691</a></li></ul><p><strong>final关键字</strong></p><ul><li><a href="http://www.importnew.com/7553.html" target="_blank" rel="noopener">http://www.importnew.com/7553.html</a></li></ul><p><strong>基于Redis的分布式锁</strong></p><ul><li><a href="https://segmentfault.com/a/1190000012919740" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012919740</a></li></ul><p><strong>数据库分布式锁</strong></p><ul><li><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1716</a></li></ul><p><strong>防备DDOS攻击(*)</strong></p><ul><li><a href="https://www.zhihu.com/question/19581905" target="_blank" rel="noopener">https://www.zhihu.com/question/19581905</a></li></ul><p><strong>什么时候Mysql调用行锁？(*)</strong></p><ul><li><a href="https://blog.csdn.net/songwei128/article/details/43418343" target="_blank" rel="noopener">https://blog.csdn.net/songwei128/article/details/43418343</a></li></ul><p><strong>CMS,G1(*)</strong></p><ul><li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a></li></ul><p><strong>内部类，外部类互访(*)</strong></p><ul><li><a href="https://blog.csdn.net/jueblog/article/details/13434551" target="_blank" rel="noopener">https://blog.csdn.net/jueblog/article/details/13434551</a></li><li><a href="https://blog.csdn.net/Van_L_/article/details/54667365" target="_blank" rel="noopener">https://blog.csdn.net/Van_L_/article/details/54667365</a></li></ul><p><strong>设计模式(*)</strong><br>熟背单例模式和工厂模式，会写适配器和建造者也行</p><ul><li><a href="https://www.jianshu.com/p/8a293e4a888e" target="_blank" rel="noopener">https://www.jianshu.com/p/8a293e4a888e</a></li><li><a href="https://segmentfault.com/a/1190000004255439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004255439</a></li></ul><p><strong>深拷贝，浅拷贝(*)</strong></p><ul><li><a href="https://segmentfault.com/a/1190000010648514" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010648514</a></li></ul><p><strong>泛型擦除</strong></p><ul><li><a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/76736356</a></li></ul><p><strong>Java 8 Stream, 函数编程</strong></p><ul><li><a href="https://www.jianshu.com/p/0c07597d8311" target="_blank" rel="noopener">https://www.jianshu.com/p/0c07597d8311</a></li><li><a href="https://www.jianshu.com/p/9bd647bcf1e3" target="_blank" rel="noopener">https://www.jianshu.com/p/9bd647bcf1e3</a></li></ul><p><strong>中断线程</strong></p><ul><li><a href="https://www.jianshu.com/p/264d4e1b76af" target="_blank" rel="noopener">https://www.jianshu.com/p/264d4e1b76af</a></li></ul><p><strong>Lock，tryLock，lockInterruptibly区别</strong></p><ul><li><a href="https://blog.csdn.net/u013851082/article/details/70140223" target="_blank" rel="noopener">https://blog.csdn.net/u013851082/article/details/70140223</a></li></ul><p><strong>JUC</strong></p><ul><li><a href="http://www.cnblogs.com/chenpi/p/5358579.html#_label2" target="_blank" rel="noopener">http://www.cnblogs.com/chenpi/p/5358579.html#_label2</a></li><li><a href="http://www.cnblogs.com/chenpi/p/5614290.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpi/p/5614290.html</a></li></ul><p><strong>NIO</strong></p><ul><li><a href="https://blog.csdn.net/u013063153/article/details/76473578" target="_blank" rel="noopener">https://blog.csdn.net/u013063153/article/details/76473578</a></li><li><a href="https://www.jianshu.com/p/052035037297" target="_blank" rel="noopener">https://www.jianshu.com/p/052035037297</a></li><li><a href="https://segmentfault.com/a/1190000006824196" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006824196</a></li></ul><p><strong>Start和run区别(*)</strong></p><ul><li><a href="https://blog.csdn.net/qq_36544760/article/details/79380963" target="_blank" rel="noopener">https://blog.csdn.net/qq_36544760/article/details/79380963</a></li></ul><p><strong>jvm内存屏障</strong></p><ul><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">https://www.jianshu.com/p/2ab5e3d7e510</a></li></ul><p><strong>Java构造器能被重载，但是不能被重写(*)</strong></p><ul><li><a href="https://blog.csdn.net/weixin_36513603/article/details/54968094" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36513603/article/details/54968094</a></li></ul><p><strong>HttpSession</strong></p><ul><li><a href="https://blog.csdn.net/zy2317878/article/details/80275463" target="_blank" rel="noopener">https://blog.csdn.net/zy2317878/article/details/80275463</a></li></ul><p><strong>Thread类的方法</strong></p><ul><li><a href="https://blog.csdn.net/gxx_csdn/article/details/79210192" target="_blank" rel="noopener">https://blog.csdn.net/gxx_csdn/article/details/79210192</a></li></ul><p><strong>String是值类型，还是引用类型(*)</strong></p><ul><li><a href="https://blog.csdn.net/a220315410/article/details/27743607" target="_blank" rel="noopener">https://blog.csdn.net/a220315410/article/details/27743607</a></li></ul><p><strong>Redis 实现消息队列</strong></p><ul><li><p>消息/订阅+List</p></li><li><p><a href="https://segmentfault.com/a/1190000012244418" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012244418</a></p></li></ul><p><strong>minor gc full gc 区别(*)</strong></p><ul><li><a href="https://blog.csdn.net/u010796790/article/details/52213708" target="_blank" rel="noopener">https://blog.csdn.net/u010796790/article/details/52213708</a></li></ul><p><strong>Java如何查看死锁</strong></p><ul><li><a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">https://blog.csdn.net/u014039577/article/details/52351626</a></li><li><a href="https://juejin.im/post/5aaf6ee76fb9a028d3753534" target="_blank" rel="noopener">https://juejin.im/post/5aaf6ee76fb9a028d3753534</a></li></ul><p><strong>c3p0，dbcp与druid</strong></p><ul><li><a href="https://blog.csdn.net/qq_34359363/article/details/72763491" target="_blank" rel="noopener">https://blog.csdn.net/qq_34359363/article/details/72763491</a></li></ul><p><strong>Spring Bean 生命周期(*)</strong></p><ul><li><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="noopener">https://www.jianshu.com/p/3944792a5fff</a></li></ul><p><strong>Spring的BeanFactory和ApplicationContext的区别?</strong></p><ul><li><p>ApplicationContext是实现类，继承ListableBeanFactory（继承BeanFactory），功能更多</p></li><li><p>ApplicationContext默认立即加载，BeanFactory懒加载</p></li><li><p><a href="https://my.oschina.net/yao00jun/blog/215642" target="_blank" rel="noopener">https://my.oschina.net/yao00jun/blog/215642</a></p></li><li><p><a href="https://blog.csdn.net/qq_36748278/article/details/78264764" target="_blank" rel="noopener">https://blog.csdn.net/qq_36748278/article/details/78264764</a></p></li></ul><p><strong>Java 如何有效地避免OOM：善于利用软引用和弱引用</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3784171.html</a></li></ul><p><strong>分布式数据库主键生成策略(*)</strong></p><ul><li><a href="https://www.jianshu.com/p/a0a3aa888a49" target="_blank" rel="noopener">https://www.jianshu.com/p/a0a3aa888a49</a></li><li><a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/MT_Leaf.html</a></li></ul><p><strong>String底层(*)</strong></p><ul><li><a href="https://blog.csdn.net/yadicoco49/article/details/77627302" target="_blank" rel="noopener">https://blog.csdn.net/yadicoco49/article/details/77627302</a></li></ul><p><strong>count(1)、count(*)与count(列名)的执行区别</strong></p><ul><li><a href="https://blog.csdn.net/iFuMI/article/details/77920767" target="_blank" rel="noopener">https://blog.csdn.net/iFuMI/article/details/77920767</a></li></ul><p><strong>主键，唯一索引区别</strong></p><ul><li>1）主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</li><li>2）主键不允许为空值，唯一索引列允许空值；</li><li>3）一个表只能有一个主键，但是可以有多个唯一索引；</li><li>4）主键可以被其他表引用为外键，唯一索引列不可以；</li><li>5）主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别</li></ul><p><strong>死锁</strong><br>产生死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>避免死锁：<br><a href="https://segmentfault.com/a/1190000000378725" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000378725</a></p><ul><li>确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生.</li><li>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。</li><li>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</li></ul><p><strong>乐观锁，悲观锁(*)</strong></p><ul><li><a href="https://blog.csdn.net/lovejj1994/article/details/79116272" target="_blank" rel="noopener">https://blog.csdn.net/lovejj1994/article/details/79116272</a></li></ul><p><strong>公平锁、非公平锁</strong></p><ul><li>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待<br>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列<br>Java中的ReentrantLock 默认的lock()方法采用的是非公平锁。</li></ul><p><strong>OOM分析</strong></p><ul><li><a href="https://blog.csdn.net/zheng12tian/article/details/40617369" target="_blank" rel="noopener">https://blog.csdn.net/zheng12tian/article/details/40617369</a></li></ul><p><strong>JVM调优参数</strong><br>知道-Xms，-Xmx，-XX:NewRatio=n，会算就行，笔试题考过</p><ul><li><a href="https://www.jianshu.com/p/a2a6a0995fee" target="_blank" rel="noopener">https://www.jianshu.com/p/a2a6a0995fee</a></li></ul><p>堆设置</p><ul><li>-Xms:初始堆大小<br>-Xmx:最大堆大小<br>-XX:NewSize=n:设置年轻代大小<br>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>-XX:MaxPermSize=n:设置持久代大小</li></ul><p>收集器设置</p><ul><li>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><p>垃圾回收统计信息</p><ul><li>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</li></ul><p>并行收集器设置</p><ul><li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li></ul><p>并发收集器设置</p><ul><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul><p>调优总结<br>年轻代大小选择</p><ul><li>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。<br>吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</li></ul><p>年老代大小选择</p><ul><li>响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：<br>并发垃圾收集信息 持久代并发收集次数 传统GC信息 花在年轻代和年老代回收上的时间比例 减少年轻代和年老代花费的时间，一般会提高应用的效率<br>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</li></ul><p>较小堆引起的碎片问题</p><ul><li>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：<br>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。<br>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</li></ul><p><strong>synchronized实现原理(*)</strong></p><ul><li><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a></li><li>内存对象头， Mark Word保存锁信息</li><li>JVM层：Monitor对象，字节码中的monitorenter 和 monitorexit 指令</li><li>无锁，偏向锁，轻量级锁（自选），重量级锁</li><li>可重入</li><li>notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因.</li></ul><p><strong>synchronized, lock区别(*)</strong></p><ul><li><a href="https://blog.csdn.net/u012403290/article/details/64910926" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/64910926</a></li></ul><p><strong>Spring容器中Bean的作用域(*)</strong><br>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p><ul><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：对于每次HTTP<br>Session，使用session定义的Bean产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li><li>globalsession：每个全局的HTTP<br>Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet<br>context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li></ul><p>　　其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p><p>　　如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p><p><strong>Spring IOC实现原理， 相关知识(*)</strong></p><p>Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。<br><img src="https://upload-images.jianshu.io/upload_images/7240015-4669f4f39a4bd7ea?imageMogr2/auto-orient/strip%7CimageView2/2/w/566" alt="enter image description here"></p><p>Bean缓存池：HashMap实现</p><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；</p><p>ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</p><p><img src="https://upload-images.jianshu.io/upload_images/7240015-6f4b90fac05c6c36?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="enter image description here"></p><p>BeanDefinitionRegistry： Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。</p><p>BeanFactory 接口位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：</p><p>ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</p><p>HierarchicalBeanFactory：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</p><p>ConfigurableBeanFactory：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</p><p>AutowireCapableBeanFactory：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</p><p>SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例 Bean 的方法；</p><p>  <strong>@Bean, @Component 区别</strong></p><ul><li>Componet 一般放在类上面，Bean放在方法上面，自己可控制是否生成bean.<br>bean 一般会放在classpath scanning路径下面，会自动生成bean.<br>有Componet /bean生成的bean都提供给autowire使用.</li><li>在@Component中(@Component标注的类，包括@Service,@Repository, @Controller)使用@Bean注解和在@Configuration中使用是不同的。在@Component类中使用方法或字段时不会使用CGLIB增强(及不使用代理类：调用任何方法，使用任何变量，拿到的是原始对象，后面会有例子解释)。而在@Configuration类中使用方法或字段时则使用CGLIB创造协作对象（及使用代理：拿到的是代理对象）;当调用@Bean注解的方法时它不是普通的Java语义，而是从容器中拿到的由Spring生命周期管理、被Spring代理甚至依赖于其他Bean的对象引用。在@Component中调用@Bean注解的方法和字段则是普通的Java语义，不经过CGLIB处理。</li></ul><p><strong>如何停止线程？</strong></p><ul><li>主线程提供volatile boolean flag, 线程内while判断flag</li><li>线程内while(!this.isInterrupted), 主线程里调用interrupt</li><li>if(this.isInterrupted) throw new InterruptedException() 或return，主线程里调用interrupt</li><li>将一个线程设置为守护线程后，当进程中没有非守护线程后，守护线程自动结束</li></ul><p><strong>多线程实现方式？(*)</strong></p><ul><li>extends Thread</li><li>implements Runnable</li><li>implements Callable, 重写call, 返回future (主线程可以用线程池submit)</li></ul><p><strong>线程池(*)</strong><br>线程池处理过程：</p><ul><li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li><li>如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务(注意，执行这一步骤需要获取全局锁)。</li><li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li></ul><p>四种线程池:</p><ul><li>CachedThreadPool</li><li>FixedThreadPool</li><li>ScheduledThreadPool</li><li>SingleThreadExecutor</li></ul><p>创建线程池的参数：</p><ul><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li><li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。<br>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li><li>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</li><li>ThreadFactory：用于设置创建线程的工厂</li><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK<br>1.5中Java线程池框架提供了以下4种策略。  AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。<br>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。</li></ul><p>*<em>ArrayList,LinkedList *</em></p><ul><li>ArrayList初始化可以指定大小，知道大小的建议指定<br>arraylist添加元素的时候，需要判断存放元素的数组是否需要扩容（扩容大小是原来大小的1/2+1）</li><li>LinkedList添加、删除元素通过移动指针 LinkedList遍历比arraylist慢，建议用迭代器</li><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>对于随机访问get和set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。（参考数组与链表来思考）</li><li>对于新增和删除操作add和remove，LinedList比较占优势，只需要对指针进行修改即可，而ArrayList要移动数据来填补被删除的对象的空间。</li></ul><p><strong>HashMap原理(*)</strong></p><ul><li>HashMap<strong>最多只允许一条Entry的键为Null</strong>(多条会覆盖)，但允许多条Entry的值为Null</li><li>HashSet 本身就是在 HashMap 的基础上实现的.</li><li>若负载因子越大，那么对空间的利用更充分，但查找效率的也就越低；若负载因子越小，那么哈希表的数据将越稀疏，对空间造成的浪费也就越严重。系统默认负载因子0.75</li><li>调用put方法存值时，HashMap首先会调用Key的hashCode方法，然后基于此获取Key哈希码，通过哈希码快速找到某个桶，这个位置可以被称之为bucketIndex.如果两个对象的hashCode不同，那么equals一定为false；否则，如果其hashCode相同，equals也不一定为 true。所以，理论上，hashCode可能存在碰撞的情况，当碰撞发生时，这时会取出bucketIndex桶内已存储的元素，并通过hashCode() 和 equals()来逐个比较以判断Key是否已存在。如果已存在，则使用新Value值替换旧Value值，并返回旧Value值；如果不存在，则存放新的键值对&lt;Key, Value&gt;到桶中。因此，在 HashMap中，equals() 方法只有在哈希码碰撞时才会被用到。</li><li>首先，判断key是否为null，若为null，则直接调用putForNullKey方法；若不为空，则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则查找是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。此外，若table在该处没有元素，则直接保存。</li><li>HashMap 永远都是在链表的表头添加新元素。</li></ul><p>hash()和indexFor()</p><pre><code>static int hash(int h) {    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}static int indexFor(int h, int length) {    return h &amp; (length-1);  // 作用等价于取模运算，但这种方式效率更高}</code></pre><ul><li>hash() 方法用于对Key的hashCode进行重新计算，而 indexFor()方法用于生成这个Entry对象的插入位置。当计算出来的hash值与hashMap的(length-1)做了&amp;运算后，会得到位于区间[0，length-1]的一个值。特别地，这个值分布的越均匀，HashMap 的空间利用率也就越高，存取效率也就越好，保证元素均匀分布到table的每个桶中以便充分利用空间。</li><li>hash():使用hash()方法对一个对象的hashCode进行重新计算是为了<strong>防止质量低下的hashCode()函数实现</strong>。由于hashMap的支撑数组长度总是2 的幂次，通过右移可以使低位的数据尽量的不同，从而使hash值的分布尽量均匀。</li><li>indexFor():<strong>保证元素均匀分布</strong>到table的每个桶中; 当length为2的n次方时，h&amp;(length -1)就相当于对length取模，而且速度比直接取模要快得多，这是HashMap在速度上的一个优化.</li></ul><p>扩容resize()和重哈希transfer()</p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    // 若 oldCapacity 已达到最大值，直接将 threshold 设为 Integer.MAX_VALUE    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;             // 直接返回    }    // 否则，创建一个更大的数组    Entry[] newTable = new Entry[newCapacity];    //将每条Entry重新哈希到新的数组中    transfer(newTable);    table = newTable;    threshold = (int) (newCapacity * loadFactor);  // 重新设定 threshold}void transfer(Entry[] newTable) {    // 将原数组 table 赋给数组 src    Entry[] src = table;    int newCapacity = newTable.length;    // 将数组 src 中的每条链重新添加到 newTable 中    for (int j = 0; j &lt; src.length; j++) {        Entry&lt;K,V&gt; e = src[j];        if (e != null) {            src[j] = null;   // src 回收            // 将每条链的每个元素依次添加到 newTable 中相应的桶中            do {                Entry&lt;K,V&gt; next = e.next;                // e.hash指的是 hash(key.hashCode())的返回值;                // 计算在newTable中的位置，注意原来在同一条子链上的元素可能被分配到不同的子链                int i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            } while (e != null);        }    }}</code></pre><ul><li>为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理，该临界点就是HashMap中元素的数量在数值上等于threshold（table数组长度*加载因子)</li><li>重哈希的主要是一个重新计算原HashMap中的元素在新table数组中的位置并进行复制处理的过程</li></ul><p>HashMap 的底层数组长度为何总是2的n次方</p><ul><li>当底层数组的length为2的n次方时， h&amp;(length - 1) 就相当于对length取模，而且速度比直接取模<strong>快</strong>得多，这是HashMap在速度上的一个优化</li><li>不同的hash值发生碰撞的概率比较小，这样就会使得<strong>数据在table数组中分布较均匀</strong>，空间利用率较高，查询速度也较快</li></ul><p><strong>ConcurrenytHashMap原理(*)</strong></p><ul><li><a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72783008</a></li></ul><p><img src="http://static.zybuluo.com/Rico123/1htf73l5swe0jek5a50fn4hi/ConcurrentHashMap%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="enter image description here"></p><ul><li>通过锁分段技术保证并发环境下的写操作；<br>通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；<br>通过不加锁和加锁两种方案控制跨段操作的的安全性。</li></ul><p>HashMap线程不安全</p><ul><li><a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72783008</a></li><li>在HashMap进行扩容重哈希时导致Entry链形成环。一旦Entry链中有环，势必会导致在同一个桶中进行插入、查询、删除等操作时陷入<strong>死循环</strong>。</li></ul><p>Segment数组</p><pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLockimplements Serializable {    transient volatile int count;    // Segment中元素的数量，可见的    transient int modCount;  //对count的大小造成影响的操作的次数（比如put或者remove操作）    transient int threshold;      // 阈值，段中元素的数量超过这个值就会对Segment进行扩容    transient volatile HashEntry&lt;K,V&gt;[] table;  // 链表数组    final float loadFactor;  // 段的负载因子，其值等同于ConcurrentHashMap的负载因子    ...}</code></pre><ul><li><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色</p></li><li><p>在Segment类中，count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组包含的 HashEntry 对象的个数，也就是 Segment 中包含的 HashEntry 对象的总数。特别需要注意的是，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是对 ConcurrentHashMap 并发性的考虑：<strong>因为这样当需要更新计数器时，不用锁定整个ConcurrentHashMap。</strong>事实上，每次对段进行结构上的改变，如在段中进行增加/删除节点(修改节点的值不算结构上的改变)，都要更新count的值，此外，在JDK的实现中<strong>每次读取操作开始都要先读取count的值</strong>。特别需要注意的是，<strong>count是volatile</strong>的，这使得对count的任何更新对其它线程都是立即可见的。<strong>modCount用于统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变</strong>.<strong>table</strong>是一个典型的链表数组，而且也是<strong>volatile</strong>的，这使得对table的任何更新对其它线程也都是立即可见的。</p></li></ul><p>HashEntry</p><pre><code>static final class HashEntry&lt;K,V&gt; {   final K key;                       // 声明 key 为 final 的   final int hash;                   // 声明 hash 值为 final 的   volatile V value;                // 声明 value 被volatile所修饰   final HashEntry&lt;K,V&gt; next;      // 声明 next 为 final 的    HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {        this.key = key;        this.hash = hash;        this.next = next;        this.value = value;    }    @SuppressWarnings(&quot;unchecked&quot;)    static final &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(int i) {    return new HashEntry[i];    }}</code></pre><ul><li>在HashEntry类中，key，hash和next域都被声明为<strong>final</strong>的，value域被volatile所修饰，因此HashEntry对象几乎是不可变的，这是ConcurrentHashmap<strong>读操作并不需要加锁</strong>的一个重要原因</li><li>由于value域被<strong>volatile</strong>修饰，所以其可以确保被读线程读到最新的值，这是ConcurrentHashmap<strong>读操作并不需要加锁</strong>的另一个重要原因</li></ul><p>put(), get()</p><ul><li><p>不允许key值为null，也不允许value值为null</p></li><li><p><strong>HashTable 和由同步包装器包装的HashMap每次只能有一个线程执行读或写操作</strong>，ConcurrentHashMap 在并发访问性能上有了质的提高。在理想状态下，ConcurrentHashMap 可以支持 <strong>16 个线程</strong>执行<strong>并发写操作</strong>（如果并发级别设置为 16），及<strong>任意数量线程的读操作</strong>。</p><p>重哈希rehash()</p></li></ul><ul><li>ConcurrentHashMap的重哈希实际上是对ConcurrentHashMap的某个段的重哈希，因此ConcurrentHashMap的每个段所包含的桶位自然也就不尽相同</li></ul><p>存在key-value为null的特殊情况</p><pre><code>V get(Object key, int hash) {        if (count != 0) {            // read-volatile，首先读 count 变量            HashEntry&lt;K,V&gt; e = getFirst(hash);   // 获取桶中链表头结点            while (e != null) {                if (e.hash == hash &amp;&amp; key.equals(e.key)) {    // 查找链中是否存在指定Key的键值对                    V v = e.value;                    if (v != null)  // 如果读到value域不为 null，直接返回                        return v;                    // 如果读到value域为null，说明发生了重排序，加锁后重新读取                    return readValueUnderLock(e); // recheck                }                e = e.next;            }        }        return null;  // 如果不存在，直接返回null    }</code></pre><ul><li>初始化HashEntry时发生的指令重排序导致的，也就是在HashEntry初始化完成之前便返回了它的引用</li><li>加锁重读</li></ul><p>读操作不需要加锁</p><ul><li>用HashEntery对象的不变性来降低读操作对加锁的需求；</li><li>用Volatile变量协调读写线程间的内存可见性；</li><li>若读时发生指令重排序现象，则加锁重读；</li></ul><p>结构性操作的并发安全</p><pre><code>remove(Object key, int hash, Object value) {       lock();     // 加锁       try {           int c = count - 1;           HashEntry&lt;K,V&gt;[] tab = table;           int index = hash &amp; (tab.length - 1);        // 定位桶           HashEntry&lt;K,V&gt; first = tab[index];           HashEntry&lt;K,V&gt; e = first;           while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))  // 查找待删除的键值对               e = e.next;           V oldValue = null;           if (e != null) {    // 找到               V v = e.value;               if (value == null || value.equals(v)) {                   oldValue = v;                   // All entries following removed node can stay                   // in list, but all preceding ones need to be                   // cloned.                   ++modCount;                   // 所有处于待删除节点之后的节点原样保留在链表中                   HashEntry&lt;K,V&gt; newFirst = e.next;                   // 所有处于待删除节点之前的节点被克隆到新链表中                   for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)                       newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,newFirst, p.value);                   tab[index] = newFirst;   // 将删除指定节点并重组后的链重新放到桶中                   count = c;      // write-volatile，更新Volatile变量count               }           }           return oldValue;       } finally {           unlock();          // finally子句解锁       }   }</code></pre><ul><li>clear操作只是把ConcurrentHashMap中所有的桶置空，每个桶之前引用的链表依然存在，只是桶不再引用这些链表而已，而链表本身的结构并没有发生任何修改。</li><li>put操作如果需要插入一个新节点到链表中时会在链表头部插入这个新节点，此时链表中的原有节点的链接并没有被修改</li><li>在执行remove操作时，原始链表并没有被修改</li><li>只要之前对链表做结构性修改操作的写线程M在退出写方法前写volatile变量count（segment中的，segment中元素的个数），读线程N就能读取到这个volatile变量count的最新值</li></ul><p>跨segment操作</p><ul><li>size(): JDK只需要在统计size前后比较modCount（Segment中的）是否发生变化就可以得知容器的大小是否发生变化</li><li>size方法主要思路是先在没有锁的情况下对所有段大小求和，这种求和策略最多执行RETRIES_BEFORE_LOCK次(默认是两次)：在没有达到RETRIES_BEFORE_LOCK之前，求和操作会不断尝试执行（这是因为遍历过程中可能有其它线程正在对已经遍历过的段进行结构性更新）；在超过RETRIES_BEFORE_LOCK之后，如果还不成功就在持有所有段锁的情况下再对所有段大小求和。</li></ul><p><strong>JVM内存模型(*)</strong><br>必考，熟背</p><p><img src="http://static.zybuluo.com/Rico123/wozzd000rzpwwpz4eqi0xf1j/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="enter image description here"></p><ul><li><strong>线程私有的数据区 包括 程序计数器、 虚拟机栈 和 本地方法栈</strong></li><li><strong>线程共享的数据区 具体包括 Java堆 和 方法区</strong></li></ul><p>线程计数器</p><ul><li>在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据 时间片轮询抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。</li></ul><p>虚拟机栈</p><ul><li>每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程</li></ul><p>本地方法栈</p><ul><li>本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常</li></ul><p>Java堆</p><ul><li>Java 堆的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例（和数组）都在这里分配内存</li><li>Java堆可以处于<strong>物理上不连续的内存空间中，只要逻辑上是连续</strong>的即可。而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。</li><li>TLAB (线程私有分配缓冲区) : 虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。</li></ul><p>方法区</p><ul><li>方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于<strong>存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据</li><li>运行时常量池：是方法区的一部分，用于存放编译期生成的各种 <strong>字面量 和 符号引用</strong>. 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值.  符号引用:包括以下三类常量：类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符.</li></ul><p>方法区的回收</p><ul><li>主要是针对 常量池的回收 （判断引用） 和 对类型的卸载</li><li>回收类: 1) 该类所有的<strong>实例都已经被回收</strong>，也就是Java堆中不存在该类的任何实例加载 2) 该类的<strong>ClassLoader已经被回收</strong> 3) 该类对应的 <strong>java.lang.Class 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul><p><strong>垃圾回收机制(*)</strong><br>必考，熟背</p><p>引用计数法</p><ul><li>循环引用</li></ul><p>可达性分析算法</p><ul><li>通过一系列的名为 “<strong>GC Roots</strong>” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的</li><li><strong>虚拟机栈(栈帧中的局部变量表)中引用的对象</strong></li><li><strong>方法区中类静态属性引用的对象</strong></li><li><strong>方法区中常量引用的对象</strong></li><li><strong>本地方法栈中Native方法引用的对象</strong></li></ul><p>标记清除算法</p><ul><li>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收</li><li>效率问题：标记和清除两个过程的效率都不高;</li><li>空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会<strong>导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong></li></ul><p>复制算法</p><ul><li>　复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>这种算法适用于对象存活率低的场景，比如新生代</strong>。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>实践中会将新生代内存分为<strong>一块较大的Eden空间和两块较小的Survivor空间</strong> (如下图所示)，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</li></ul><p><img src="http://static.zybuluo.com/Rico123/pml3jw51zgc8mqffpwt6793t/heap.bmp" alt="enter image description here"></p><ul><li>现在商用的虚拟机都采用这种算法来回收新生代</li></ul><p>为什么分代收集</p><ul><li>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率.</li></ul><p>新生代进入老生代的情况</p><ul><li>对象优先在Eden分配，当<strong>Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</strong>。现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后处理掉Eden和刚才的Survivor空间。（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）当<strong>Survivor空间不够用时，需要依赖老年代</strong>进行分配担保。</li><li><strong>大对象直接进入老年代</strong>。所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</li><li><strong>长期存活的对象(-XX:MaxTenuringThreshold)</strong>将进入老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</li><li>动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中<strong>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到MaxTenuringThreshold中要求的年龄。</li></ul><p>内存分配担保机制</p><ul><li><p>我们知道如果对象在复制到Survivor区时若Survivor空间不足，则会出发担保机制，将对象转入老年代；但老年代的能力也不是无限的，因此需要在minor GC时做一个是否需要Major GC 的判断：</p></li><li><p>如果老年代的剩余空间 &lt; 之前转入老年代的对象的平均大小，则触发Major GC</p></li><li><p>如果老年代的剩余空间 &gt; 之前转入老年代的对象的平均大小，并且允许担保失败，则直接Minor GC，不需要做Full GC</p></li><li><p>如果老年代的剩余空间 &gt; 之前转入老年代的对象的平均大小，并且不允许担保失败，则触发Major GC</p><p>出发点还是尽量为对象分配内存。但是一般会配置允许担保失败，避免频繁的去做Full GC。</p></li></ul><p>标记整理算法</p><ul><li>标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法<strong>适用于对象存活率高的场景（老年代）</strong></li><li><strong>无内存碎片</strong></li></ul><p>新生代、老年代、永久代</p><ul><li>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的. 如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</li><li>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中</li><li>永久代主要用于存放静态文件，如Java类、方法等</li></ul><p>垃圾收集器<br><img src="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="enter image description here"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>ParNew收集器 (复制算法):新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 =用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><p>CMS,G1</p><ul><li><a href="https://blog.csdn.net/huanbia/article/details/75581423" target="_blank" rel="noopener">https://blog.csdn.net/huanbia/article/details/75581423</a></li></ul><p>内存泄露问题</p><ul><li><strong>静态集合类:</strong> 如 HashMap、Vector 等集合类的静态使用最容易出现内存泄露，因为这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放</li><li>各种资源连接包括<strong>数据库连接、网络连接、IO连接</strong>等没有显式调用close关闭</li><li><strong>监听器</strong>的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li></ul><p><strong>MYSQL索引(*)</strong></p><p>建立索引</p><ul><li>表的主键、外键必须有索引；</li><li>数据量超过300的表应该有索引；</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>频繁进行数据操作的表，不要建立太多的索引；</li></ul><p>索引失效</p><ul><li><p><strong>字符串不加单引号</strong></p></li><li><p>将要使用的索引列<strong>不是复合索引列表中的第一部分</strong>，则不会使用索引</p></li><li><p>应尽量<strong>避免在 where 子句中对字段进行 null 值判断</strong>，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num is null</p></li><li><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num=0</p></li><li><p>应尽量<strong>避免在 where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p></li><li><p>应尽量<strong>避免在 where 子句中使用 or 来连接条件 (用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到)</strong>，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num=10 or num=20</p></li><li><p>可以这样查询：<br>select id from t where num=10<br>union all<br>select id from t where num=20</p></li><li><p><strong>in 和 not in 也要慎用</strong>，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：<br>select id from t where num in(1,2,3)</p></li><li><p>对于<strong>连续的数值，能用 between 就不要用 in</strong> 了：<br>select id from t where num between 1 and 3</p></li><li><p>尽量<strong>避免在索引过的字符数据中，使用非打头字母%搜索</strong>。这也使得引擎无法利用索引。<br>见如下例子：<br>SELECT * FROM T1 WHERE NAME LIKE ‘%L%’<br>SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=’L’<br>SELECT * FROM T1 WHERE NAME LIKE ‘L%’</p></li><li><p>即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作</p></li><li><p>应尽量<strong>避免在 where 子句中对字段进行表达式操作</strong>，这将导致引擎放弃使用索引而进行全表扫描</p></li><li><p>应尽量<strong>避免在where子句中对字段进行函数操作</strong>，这将导致引擎放弃使用索引而进行全表扫描</p></li><li><p>不要在 <strong>where 子句中的“=”左边进行函数、算术运算或其他表达式运算</strong>，否则系统将可能无法正确使用索引</p></li></ul><p>共享锁，排他锁</p><ul><li><strong>InnoDB普通 select 语句默认不加锁</strong>(快照读，MYISAM会加锁)，而CUD操作默认加排他锁</li><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——<strong>MVCC</strong> (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：<strong>读不加锁</strong>，<strong>读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</li><li>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读.MVCC 在语境中倾向于 “对多行数据打快照造平行宇宙”，然而 CAS 一般只是保护单行数据而已</li><li>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li><li>SELECT … LOCK IN SHARE MODE ：<strong>共享锁(</strong>S锁, share locks)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</li><li>SELECT … FOR UPDATE：<strong>排他锁</strong>(X锁, exclusive locks)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</li><li>InnoDB<strong>默认隔离级别 可重复读</strong>(Repeated Read)</li><li>查询字段未加索引（主键索引、普通索引等）时，使用表锁</li><li>InnoDB行级锁基于索引实现</li><li><strong>索引数据重复率太高会导致全表扫描</strong>：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li></ul><p>隔离级别</p><ul><li><strong>Read Uncommitted</strong>（读取未提交内容）: 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</li><li><strong>Read Committed</strong>（读取提交内容）:  这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</li><li><strong>Repeatable Read</strong>（可重读）: 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</li><li><strong>Serializable</strong>（可串行化): 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争.</li></ul><p><strong>Spring IOC 怎么注入类，怎么实例化对象</strong><br>实例化</p><ul><li>Spring IoC容器则需要<strong>根据Bean定义里的配置元数据使用反射机制来创建Bean</strong></li><li>使用<strong>构造器</strong>实例化Bean 有参/无参;使用<strong>静态工厂</strong>实例化Bean;使用<strong>实例工厂</strong>实例化Bean.</li><li>使用@Autowire注解注入的时机则是容器刚启动的时候就开始注入；注入之前要先初始化bean；ApplicationContext 的初始化和BeanFactory 有一个重大的区别：BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean 时才实例目标Bean；而ApplicationContext 则在初始化应用上下文时就实例化所有单实例的Bean。</li></ul><p>注入</p><ul><li>接口、setter、构造器</li></ul><p><strong>AOP(*)</strong><br>动态代理</p><pre><code>@Aspectpublic class Audience{    @Before(&quot;execution(** concert.Performance.perform(..))&quot;)        // 表演之前    public void silenceCellPhones()    {        System.out.println(&quot;Silencing cell phones&quot;);    }    @Before(&quot;execution(** concert.Performance.perform(..))&quot;)        // 表演之前    public void takeSeats()    {        System.out.println(&quot;Taking seats&quot;);    }    @AfterReturning(&quot;execution(** concert.Performance.perform(..))&quot;)        // 表演之后    public void applause()    {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    @AfterThrowing(&quot;execution(** concert.Performance.perform(..))&quot;)        // 表演失败之后    public void demandRefound()    {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><ul><li><strong>JDK动态代理，接口，用Proxy.newProxyInstance生成代理对象，InvocationHandler</strong></li><li><strong>CGLIB，类，用enhancer生成代理对象，MethodInteceptor</strong></li><li><strong>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP ;<br>如果目标对象实现了接口，可以强制使用CGLIB实现AOP ;<br>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</strong>;</li><li>切点+注解</li><li>AspectJ是一个比较牛逼的AOP框架，他可以对类的成员变量，方法进行拦截。由于 AspectJ 是 Java 语言语法和语义的扩展，所以它提供了自己的一套处理方面的关键字。除了包含字段和方法之外，AspectJ 的方面声明还包含切入点和通知成员。<br>Spring AOP依赖的是 Spring 框架方便的、最小化的运行时配置，所以不需要独立的启动器。但是，使用这个技术，只能通知从 Spring 框架检索出的对象。Spring的AOP技术只能是对方法进行拦截。<br>在spring AOP中我们同样也可以使用类似AspectJ的注解来实现AOP功能，但是这里要注意一下，使AspectJ的注解时，AOP的实现方式还是Spring AOP。Spring缺省使用J2SE动态代理来作为AOP的代理，这样任何接口都可以被代理，Spring也可以使用CGLIB代理，对于需要代理类而不是代理接口的时候CGLIB是很有必要的。如果一个业务对象没有实现接口，默认就会使用CGLIB代理。<br><strong>Spring AOP和AscpectJ之间的关系</strong>：Spring<strong>使用</strong>了和aspectj<strong>一样的注解</strong>，并使用Aspectj来做切入点解析和匹配。但是<strong>spring AOP运行时仍旧是纯的spring AOP</strong>,并不依赖于Aspectj的编译器或者织入器</li></ul><p><strong>volatile和内存模型(*)</strong></p><p>happens-before</p><ul><li>什么是happens-before<br>令A和B表示两组操作，如果A happens-before B，那么由A操作引起的内存变化，在B开始执行之前，都应该是可见的。<br>A happens-before B，不代表A在B之前执行.</li><li>如何确保happen-before<br>锁（互斥锁、读写锁等）、内存屏障</li></ul><p>内存屏障</p><ul><li>内存屏障是一个指令，这个指令可以保证屏障前后的指令遵守一定的顺序，并且保证一定的可见性</li><li>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入_内存屏障_来禁止特定类型的处理器重排序。</li></ul><p>Java内存模型</p><ul><li>屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>Java内存模型 规定<strong>所有的变量都是存在主存</strong>当中（类似于前面说的物理内存），每个<strong>线程都有自己的工作内存</strong>（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</li></ul><p>原子性</p><ul><li>只有简单的<strong>读取、赋值</strong>（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是<strong>原子操作</strong></li><li>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现</li></ul><p>可见性</p><ul><li><strong>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值</strong>. 通过 <strong>synchronized 和 Lock 也能够保证可见性</strong>，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 在释放锁之前会将对变量的修改刷新到主存当中，因此可以保证可见性</li></ul><p>有序性</p><ul><li>指令重排序</li><li>不能由于 synchronized 和 Lock 可以让线程串行执行同步代码，就说它们可以保证指令不会发生重排序</li></ul><p>volatile</p><ul><li>保证了不同线程对共享变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这个新值对其他线程来说是 立即可见</li><li><strong>禁止进行指令重排序</strong> (双重检查锁单例模式)</li><li><strong>synchronized 也可以保证可见性</strong>，因为每次运行synchronized块 或者 synchronized方法都会导致线程工作内存与主存的同步，使得其他线程可以取得共享变量的最新值。也就是说，synchronized 语义范围不但包括 volatile 具有的可见性，也包括原子性，<strong>但不能禁止指令重排序</strong>，这是二者一个功能上的差异</li></ul><p><strong>i被volatile修饰，如果多线程来运行i++，那么是否可以达到理想的效果?</strong></p><ul><li>不能，volatile不能保证操作的原子性</li></ul><p><strong>Sleep()和wait()的区别，使用wait()方法后，怎么唤醒线程(*)</strong></p><p>笔试题经常考</p><ul><li><strong>sleep方法只让出了CPU，而并不会释放同步资源锁</strong></li><li><strong>wait()方法则是指当前线程让自己暂时退让出同步资源锁</strong>，以便其他正在等待该资源的线程得到该资源进而运行</li><li>sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用</li><li>sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待<strong>调用notify()/notifyAll()唤醒指定的线程或者所有线程</strong>，才会进入锁池，不再次获得对象锁才会进入运行状态</li><li>notify让之前调用wait的线程有权利重新参与线程的调度</li></ul><p><strong>Mybatis缓存(*)</strong></p><ul><li><strong>一级缓存的作用域是同一个SqlSession</strong>，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis<strong>默认开启一级缓存</strong>。</li><li><strong>二级缓存是mapper级别的缓存</strong>，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存</li><li><a href="https://segmentfault.com/a/1190000013678579" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013678579</a></li></ul><p><strong>Redis的数据结构(*)</strong></p><ul><li>String, Hash, List, Set, ZSet</li></ul><p>Hash底层结构</p><ul><li>redis的哈希对象的底层存储可以使用ziplist（压缩列表）和hashtable</li></ul><p><strong>Redis缓存怎么运行的？</strong></p><ul><li>使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库</li><li>主从复制</li><li>哨兵模式</li></ul><p>持久化</p><ul><li>快照文件</li><li>AOF语句追加</li></ul><p>过期策略</p><ul><li><a href="https://blog.csdn.net/xiangnan129/article/details/54928672" target="_blank" rel="noopener">https://blog.csdn.net/xiangnan129/article/details/54928672</a></li></ul><p><strong>反向代理是什么？</strong></p><ul><li>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在.</li></ul><p><strong>负载均衡是什么？</strong></p><ul><li>负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行,用于解决互联网架构中的高并发和高可用的问题。</li></ul><p><strong>单例模式(*)</strong></p><p>必考，静态内部类，双重检查锁至少会写一个</p><ul><li>私有的构造方法；<br>指向自己实例的私有静态引用；<br>以自己实例为返回值的静态的公有方法。</li></ul><p>双重检查锁</p><pre><code>public class Singleton2 {private volatile static Singleton2 singleton2;private Singleton2() {}public static Singleton2 getSingleton2() {    if (singleton2 == null) {        synchronized (Singleton2.class) {            if (singleton2 == null) {                singleton2 = new Singleton2();            }        }    }    return singleton2;}}</code></pre><ul><li>第一个if (instance == null)，只有instance为null的时候，才进入synchronized.<br>第二个if (instance == null)，是为了防止可能出现多个实例的情况。</li><li>volatile: 主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。<br>　　1. 给 singleton 分配内存<br>　　2. 调用 Singleton 的构造函数来初始化成员变量，形成实例<br>　　3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）但是在 JVM 的即时编译器中存在指令重排序的优化。<br>　　也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了<br>，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</li></ul><p>静态内部类</p><pre><code>public class Singleton1 {private Singleton1() {}public static final Singleton1 getSingleton1() {    return Singleton1Holder.singleton1;}private static class Singleton1Holder {    private static final Singleton1 singleton1 = new Singleton1();}}</code></pre><p><strong>ThreadLocal内存泄露？</strong></p><pre><code>static class ThreadLocalMap {    /**     * The entries in this hash map extend WeakReference, using     * its main ref field as the key (which is always a     * ThreadLocal object).  Note that null keys (i.e. entry.get()     * == null) mean that the key is no longer referenced, so the     * entry can be expunged from table.  Such entries are referred to     * as &quot;stale entries&quot; in the code that follows.     */    static class Entry extends WeakReference&lt;ThreadLocal&gt; {        /** The value associated with this ThreadLocal. */        Object value;        Entry(ThreadLocal k, Object v) {            super(k);            value = v;        }    }    ...}</code></pre><ul><li>ThreadLocalMap里面对Key的引用是弱引用。那么，就存在这样的情况：当释放掉对threadlocal对象的强引用后，map里面的value没有被回收，但却永远不会被访问到了，因此ThreadLocal存在着内存泄露问题</li><li>Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal进行get、set操作时会清除线程Map里所有key为null的value。所以最怕的情况就是，ThreadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，线程结束后被放回线程池中而不销毁，那么如果这个线程一直不被使用或者分配使用了又不再调用get/set方法，那么这个期间就会发生真正的内存泄露。因此，最好的做法是：在不使用该ThreadLocal对象时，及时调用该对象的remove方法去移除ThreadLocal.ThreadLocalMap中的对应Entry.</li></ul><p><strong>线程死锁检测工具？</strong></p><ul><li>Jconsole, Jstack, visualVM</li></ul><p><strong>线程池调优？</strong></p><ul><li>设置最大线程数，防止线程资源耗尽；</li><li>使用有界队列，从而增加系统的稳定性和预警能力(饱和策略)；</li><li>根据任务的性质设置线程池大小：CPU密集型任务(CPU个数个线程)，IO密集型任务(CPU个数两倍的线程)，混合型任务(拆分)。</li></ul><p><strong>几种锁？</strong></p><ul><li>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</li></ul><p>偏向锁</p><ul><li>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护</li><li>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li></ul><p>自旋锁</p><ul><li>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作. 所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。</li><li>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</li></ul><p>轻量级锁</p><ul><li>线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</li></ul><p>重量级锁</p><ul><li>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</li></ul><p><img src="http://m.qpic.cn/psb?/V11B95m82dM6q3/Hq6Mg3CYXq1YV.QjqUstoTjRJAas4OQRw0ABlUsQ418!/b/dEcBAAAAAAAA&bo=AgWTAAAAAAADB7Y!&rf=viewer_4" alt="enter image description here"></p><p><strong>innoDB和MyISAM的区别? (*)</strong></p><ul><li><p><a href="https://www.jianshu.com/p/a957b18ba40d" target="_blank" rel="noopener">https://www.jianshu.com/p/a957b18ba40d</a></p></li><li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p></li><li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p></li><li><p>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p></li><li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p></li><li><p>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p></li></ul><p><strong>索引失效 (*)</strong></p><ul><li><a href="https://blog.csdn.net/qq_32331073/article/details/79041232" target="_blank" rel="noopener">https://blog.csdn.net/qq_32331073/article/details/79041232</a></li></ul><p><strong>MySQL 索引实现原理+几种索引 (*)</strong></p><p>普通索引</p><ul><li>B+ree</li><li>MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引.</li></ul><p>InnoDB</p><ul><li>InnoDB 的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。</li><li>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以 唯一 标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</li><li>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引（普通索引）搜索需要 检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录.</li></ul><p>几种索引</p><ul><li>主键索引；</li><li>唯一索引；</li><li>普通索引；</li><li>联合索引；</li><li>全文索引。</li></ul><p>辅助索引</p><ul><li><a href="https://www.cnblogs.com/xiangyangzhu/p/index.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangyangzhu/p/index.html</a></li></ul><p>为什么用B+树</p><ul><li><a href="https://blog.csdn.net/xlgen157387/article/details/79450295" target="_blank" rel="noopener">https://blog.csdn.net/xlgen157387/article/details/79450295</a></li><li>在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。</li><li>为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</li><li>总的来说，B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</li></ul><p>B+树的插入删除</p><ul><li><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></li></ul><p>为什么说B+树比B树更适合数据库索引</p><ul><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li><li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</li></ul><p><strong>JVM内存配置参数</strong></p><ul><li>-Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li><li>-Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li><li>-Xmn Java Heap Young区大小，不熟悉最好保留默认值；</li><li>-Xss 每个线程的Stack大小，不熟悉最好保留默认值；</li></ul><p><strong>extends 抽象类和 interface 区别 (*)</strong></p><ul><li>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。</li><li>接口中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final</li><li>抽象类可以有构造方法，接口中不能有构造方法。</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量。</li><li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li><li>抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态(static)方法，接口中不能包含静态(static)方法。</li><li>抽象类和接口中都可以包含静态成员变量(static)，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类只能继承一个抽象类，但是可以实现多个接口。</li><li>一个接口可以继承多个接口。</li><li>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a”关系关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，是”like-a”的关系。</li></ul><p><strong>Servlet生命周期</strong></p><ul><li>调用 init() 方法初始化</li><li>调用 service() 方法来处理客户端的请求</li><li>调用 destroy() 方法释放资源，标记自身为可回收</li><li>被垃圾回收器回收</li></ul><p><strong>Cookie, Session区别</strong></p><ul><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上</p></li><li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE</p></li><li><p>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。</p></li></ul><p><strong>非对称加密，对称加密</strong><br>对称加密（Symmetric Cryptography），又称私钥加密</p><ul><li>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret<br>key）,这种方法在密码学中叫做对称加密算法。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。对称加密通常使用的是相对较小的密钥，一般小于256<br>bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1<br>bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1<br>MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。</li></ul><p>非对称加密（Asymmetric Cryptography），又称公钥加密</p><ul><li>1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”这种方法也叫做“非对称加密算法”。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</li></ul><p>目前通信安全的方法</p><ul><li><strong>将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</strong></li></ul><p><strong>Http, Https 区别 (*)</strong></p><ul><li>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。</li></ul><p>二者之间存在如下不同：</p><ul><li>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</li><li>开销：Https通信需要证书，而证书一般需要向认证机构购买；</li><li>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。SSL协议是通过非对称密钥机制保证双方身份认证，并完成建立连接，在实际数据通信时通过对称密钥机制保障数据安全性.</li></ul><p><strong>长连接，短连接</strong></p><ul><li><a href="http://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/4694945.html</a></li><li>connection:keep-alive</li></ul><p>短连接</p><ul><li>模拟一下TCP短连接的情况:<br>client 向 server 发起连接请求<br>server 接到请求，双方建立连接<br>client 向 server 发送消息<br>server 回应 client<br>一次读写完成，此时双方任何一个都可以发起 close 操作<br>在第 5 点钟，一般都是 client 先发起 close 操作。因为一般的 server 不会回复完 client 后就立即关闭连接。<br>当然也不排除有特殊的情况。<br>从上面的描述看，短连接一般只会在 client/server 间传递一次读写操作</li><li>管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</li></ul><p>长连接</p><ul><li>再模拟一下长连接的情况:<br>client 向 server 发起连接<br>server 接到请求，双方建立连接<br>client 向 server 发送消息<br>server 回应 client<br>一次读写完成，连接不关闭<br>后续读写操作…<br>需要TCP保活功能。</li></ul><p>应用场景</p><ul><li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。 每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，<br>再操作的话那么处理速度会降低很多，所以每个操作完后都不断开， 再次处理时直接发送数据包就OK了，不用建立TCP连接。<br>例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误， 而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，<br>如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，<br>那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</li></ul><p><strong>三次握手，四次挥手(*)</strong><br>常问问题, 熟背</p><p>为什么是三次握手不是两次握手</p><ul><li>在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费</li></ul><p>为什么是四次挥手</p><ul><li><p>双向通信</p></li><li><p>假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认</p></li></ul><p><strong>GET POST区别</strong></p><ul><li><p>在客户端， Get 方式在通过 URL 提交数据，数据 在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。</p></li><li><p>GET方式提交的数据最多只能有1024字节，而POST则没有此限制。</p></li><li><p>安全性问题。使用  Get  的时候，参数会显示在地址栏上，而  Post  不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用<br>get ；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用  post 为好。</p></li><li><p>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一  URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说， GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST  请求就不那么轻松了。 POST  表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过  POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。</p></li></ul><p><strong>TCP UDP区别 (*)</strong></p><ul><li><p>TCP是面向连接的，UDP是无连接的；</p></li><li><p>TCP是可靠的，UDP是不可靠的；</p></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；</p></li><li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p></li><li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p></li></ul><p><strong>从输入网址到获得页面的过程</strong></p><ul><li>(1). 浏览器查询DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>(2). 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>(3). TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>(4). 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>(5). 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>(6). 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ul><p><strong>OSI网络体系结构与TCP/IP协议模型 (*)</strong><br><img src="http://static.zybuluo.com/Rico123/8mdrx3z0hdl5rr0n69ti1btd/OSI%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%8A%9F%E8%83%BD%E8%A1%A8%E7%A4%BA.png" alt="enter image description here"></p><p><img src="http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt="enter image description here"><br>物理层</p><ul><li>实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质</li></ul><p>数据链路层</p><ul><li>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</li></ul><p><img src="http://static.zybuluo.com/Rico123/ed9145bf4nus32fr7umxxnk7/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E8%B7%AF%E5%B1%82.png" alt="enter image description here"><br>网络层</p><ul><li>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径.</li></ul><p>传输层<br><img src="http://static.zybuluo.com/Rico123/5td1y45fm09cbhgw07o6fgfc/%E7%BD%91%E8%B7%AF%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82.png" alt="enter image description here"></p><ul><li>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示.</li></ul><p>会话层</p><ul><li>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信.</li></ul><p>表示层</p><ul><li>数据的编码，压缩和解压缩，数据的加密和解密.</li></ul><p>应用层</p><ul><li>用户的应用进程提供网络通信服务.</li></ul><p><strong>TCP和UDP分别对应的常见应用层协议</strong><br>TCP</p><ul><li>FTP,</li><li>Telnet,</li><li>SMTP,</li><li>POP3,</li><li>HTTP</li></ul><p>UDP</p><ul><li>DNS</li><li>SNMP(简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势)</li><li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li></ul><p><strong>网络层的ARP协议工作原理</strong></p><ul><li><strong>网络层的ARP协议完成了IP地址与物理地址的映射</strong>。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ul><p><strong>HTTP常见状态码</strong></p><ul><li>1×× : 请求处理中，请求已被接受，正在处理</li><li>2×× : 请求成功，请求被成功处理</li><li>200 OK</li><li>3×× : 重定向，要完成请求必须进行进一步处理</li><li>301 : 永久性转移</li><li>302 ：暂时性转移</li><li>304 ： 已缓存</li><li>4×× : 客户端错误，请求不合法</li><li>400：Bad Request,请求有语法问题</li><li>403：拒绝请求</li><li>404：客户端所访问的页面不存在</li><li>5×× : 服务器端错误，服务器不能处理合法请求</li><li>500 ：服务器内部错误</li><li>503 ： 服务不可用，稍等</li></ul><p><strong>HTTP协议是无状态的 和 Connection: keep-alive的区别</strong></p><ul><li><p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p></li><li><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p></li><li><p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p></li></ul><p><strong>属于网络112.10.200.0/21的地址是? (*)</strong><br>笔试常考</p><ul><li>前21位为网络地址，后12位为主机地址。112 对应前8位，10对应第二个8位，因此200对应第3个8位又200的二进制表示为1100<br>1000 前面已经有了16位，因此11001 是属于网络地址的。000是属于主机地址<br>那么，最大的地址为【112（十进制）】【10（十进制）】【11001  111】【<br>11111111】转换为十进制为112.10.207.255 故网络的地址范围为: 112.10.200.0~112.10.207.255</li></ul><p><strong>某一速率为100M的交换机有20个端口，其一个端口上连着一台笔记本电脑，此电脑从迅雷上下载一部1G的电影需要的时间可能是多久？</strong></p><ul><li>1GB/(100Mb/s ÷8,字节→比特)=81.92 s, 比81s大</li><li>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。</li></ul><p><strong>与10.110.12.29 mask 255.255.255.224属于同一网段的主机IP地址是?(*)</strong><br>笔试常考</p><ul><li><p>通俗理解：</p><p>子网掩码为255.255.255.224=255.255.255.<strong>111</strong>00000，也就是讲第四个字节，有三位用来表示子网号（共有000，001，010….111等8个子网号）</p><p>请看题目给的是：10.110.12.29=10.110.12.29=10.110.12.<strong>000</strong>11101，从这里看，题目给出的IP所处子网号在000段，所以跟这个IP在一个网段的IP的前27位是定的：10.110.12.000</p><p>最后5位可以是00001<del>11110（全0和全1是不行的），也就是讲IP范围为 10.110.12.<em>000</em> <strong>00000</strong></del><br>10.110.12.<em>000</em> <strong>11110</strong></p></li></ul><p><strong>数据在计算机网络中的称法？</strong></p><ul><li>应用层：报文</li><li>运输层：报文段/用户数据报</li><li>网际层：IP数据报/分组/包</li><li>数据链路层：帧</li><li>物理层：比特流</li></ul><p><strong>try catch finally  (*)</strong><br>笔试常见套路题</p><ul><li><a href="https://blog.csdn.net/aaoxue/article/details/8535754" target="_blank" rel="noopener">https://blog.csdn.net/aaoxue/article/details/8535754</a></li></ul><p><strong>OOM, Out of Memory 错误</strong></p><p>常见OOM情况</p><ul><li>Java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li><li>Java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li><li>java.lang.StackOverflowError, 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li><li>静态集合类</li></ul><p><strong>常用Linux命令</strong></p><p>cd</p><ul><li>cd /root/Docements # 切换到目录/root/Docements</li><li>cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录</li><li>cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</li></ul><p>ls</p><ul><li>-l ：列出长数据串，包含文件的属性与权限数据等</li><li>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</li><li>-d ：仅列出目录本身，而不是列出目录的文件数据</li><li>-h ：将文件容量以较易读的方式（GB，kB等）列出来</li><li>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</li></ul><p>grep<br>命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等</p><ul><li>grep [-acinv] [–color=auto] ‘查找字符串’ filename</li><li>-a ：将binary文件以text文件的方式查找数据</li><li>-c ：计算找到‘查找字符串’的次数</li><li>-i ：忽略大小写的区别，即把大小写视为相同</li><li>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</li></ul><p>find 寻找<br>find [PATH] [option] [action]<br> 与时间有关的参数：</p><ul><li>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</li><li>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</li><li>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</li><li>-newer file : 列出比file还要新的文件名</li></ul><p>cp 复制</p><ul><li>-a ：将文件的特性一起复制</li><li>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</li><li>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</li><li>-r ：递归持续复制，用于目录的复制行为</li><li>-u ：目标文件与源文件有差异时才会复制</li></ul><p>mv 移动</p><ul><li>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li><li>-i ：若目标文件已经存在，就会询问是否覆盖</li><li>-u ：若目标文件已经存在，且比目标文件新，才会更新</li></ul><p>rm 删除</p><ul><li>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</li><li>-i ：互动模式，在删除前会询问用户是否操作</li><li>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</li></ul><p>ps 查看进程</p><ul><li>-A ：所有的进程均显示出来</li><li>-a ：不与terminal有关的所有进程</li><li>-u ：有效用户的相关进程</li><li>-x ：一般与a参数一起使用，可列出较完整的信息</li><li>-l ：较长，较详细地将PID的信息列出</li><li>ps aux # 查看系统所有的进程数据</li><li>ps ax # 查看不与terminal有关的所有进程</li><li>ps -lA # 查看系统所有的进程数据</li><li>ps axjf # 查看连同一部分进程树状态</li></ul><p>kill<br>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID</p><ul><li>1：SIGHUP，启动被终止的进程</li><li>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</li><li>9：SIGKILL，强制中断一个进程的进行</li><li>15：SIGTERM，以正常的结束进程方式来终止进程</li><li>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</li></ul><p>killall</p><ul><li><p>-i ：交互式的意思，若需要删除时，会询问用户</p></li><li><p>-e ：表示后面接的command name要一致，但command name不能超过15个字符</p></li><li><p>-I ：命令名称忽略大小写</p><p>例如：</p></li><li><p>killall -SIGHUP syslogd # 重新启动syslogd</p></li></ul><p>file<br>用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的</p><ul><li>file filename</li></ul><p>例如：<br>file ./test</p><p>tar</p><ul><li>-c ：新建打包文件</li><li>-t ：查看打包文件的内容含有哪些文件名</li><li>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</li><li>-j ：通过bzip2的支持进行压缩/解压缩</li><li>-z ：通过gzip的支持进行压缩/解压缩</li><li>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</li><li>-f filename ：filename为要处理的文件</li><li>-C dir ：指定压缩/解压缩的目录dir<br>常用tar命令</li><li>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</li><li>查询：tar -jtv -f filename.tar.bz2</li><li>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><p>cat<br>用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据</p><ul><li>cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替</li></ul><p>chgrp   改变文件所属所属用户组</p><ul><li>chgrp [-R] dirname/filename</li><li>-R ：进行递归的持续对所有文件和子目录更改</li></ul><p>例如：</p><ul><li>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</li></ul><p>chown 改变文件所有者</p><p>chmod 改变文件权限</p><ul><li>chmod [-R] xyz 文件或目录</li><li>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</li></ul><p>vim</p><p><strong>JVM类加载机制 (*)</strong></p><p>面试有概率会问<br><img src="http://incdn1.b0.upaiyun.com/2017/06/2fb054008ca2898e0a17f7d79ce525a1.png" alt="enter image description here"><br>加载</p><ul><li>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</li></ul><p>验证</p><ul><li>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li></ul><p>准备</p><ul><li>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</li></ul><p>   public static int v = 8080;<br>   实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<client>方法之中，这里我们后面会解释。<br>   但是注意如果声明为： public static final int v = 8080;<br>   在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</client></p><p>解析</p><ul><li>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的： CONSTANT_Class_info<br>CONSTANT_Field_info CONSTANT_Method_info 等类型的常量。</li></ul><p>符号引用和直接引用的概念：</p><ul><li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>初始化</p><ul><li>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。<br>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。p.s:<br>如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></li></ul><p>注意以下几种情况不会执行类初始化：</p><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取Class对象，不会触发类的初始化。</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</li></ul><p><strong>给你一个未知长度的链表,怎么找到中间的那个节点?</strong><br>快慢指针，快指针走两步，慢指针走一步，快指针到尾了，慢指针走到一半。</p><p><strong>类加载器 (*)</strong></p><p>面试必考<br><img src="http://incdn1.b0.upaiyun.com/2017/06/d330251551f6de988239494ce2773095.png" alt="enter image description here"><br>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：</p><ul><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib<br>目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li><strong>扩展类加载器</strong>(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext<br>目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li><li><strong>应用程序类加载器</strong>(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</li><li>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</li><li>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</li><li>采用<strong>双亲委派</strong>的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就<strong>保证了使用不同的类加载器最终得到的都是同样一个Object对象</strong>。</li></ul><p><strong>访问权限</strong></p><ul><li>对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。</li><li>对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。</li></ul><p><strong>Spring bean 范围</strong></p><ul><li>singleton, prototype,  request, session, global session</li></ul><p><strong>进程间的通信方式，线程间的通信方式</strong><br>进程</p><ul><li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号量(semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存(shared memory )：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li><li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ul><p>线程</p><ul><li><p>锁机制：包括互斥锁、条件变量、读写锁</p><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<code>while+if+volatile变量</code></li></ul></li><li><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</p></li><li><p>信号机制(Signal)：类似进程间的信号处理</p></li></ul><p>Java线程</p><ul><li>synchoronized</li><li>wait/notify</li><li>lock condition</li><li>semaphore</li><li>countdownlatch</li><li>cyclicbarrier</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p><p><strong>MyBatis中#{}和${}区别(*)</strong></p><ul><li>#{}是经过预编译的,是安全的,而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在sql注入。</li><li>只能＄{}的情况,order by、like 语句只能用＄{}了,用#{}会多个’ ‘导致sql语句失效.此外动态拼接sql也要用${}</li><li>#{} 这种取值是编译好SQL语句再取值, ${} 这种是取值以后再去编译SQL语句</li></ul><p>重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的sql注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</p><p><strong>数据库数据不一致的原因</strong></p><ul><li>数据冗余</li></ul><p>如果数据库中存在冗余数据，比如两张表中都存储了用户的地址，在用户的地址发生改变时，如果只更新了一张表中的数据，那么这两张表中就有了不一致的数据。</p><ul><li>并发控制不当</li></ul><p>比如某个订票系统中，两个用户在同一时间订同一张票，如果并发控制不当，可能会导致一张票被两个用户预订的情况。当然这也与元数据的设计有关。</p><ul><li>故障和错误</li></ul><p>如果软硬件发生故障造成数据丢失等情况，也可能引起数据不一致的情况。因此我们需要提供数据库维护和数据恢复的一些措施。</p><p><strong>线程的状态(*)</strong></p><p>笔试常考</p><ul><li>新建( new )：新创建了一个线程对象。</li><li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start<br>()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li><li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li></ul><ul><li><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu<br>timeslice，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice<br>转到运行( running    )状态。阻塞的情况分三种：</p><p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列(waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM会把该线程置为阻塞. 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O<br>处理完毕时，线程重新转入可运行( runnable )状态。</p></li><li><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run<br>()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ul><p><img src="http://uploadfiles.nowcoder.net/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD" alt="enter image description here"></p><p><strong>如何确保N个线程可以访问N个资源同时又不导致死锁？</strong></p><p>多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是<strong>线程都是以同样的顺序加锁和释放锁</strong>，也就是破坏了第四个条件。</p><p><strong>背包问题(*)</strong><br>试题描述：小明喜欢在火车旅行的时候用手机听音乐，他有N首歌在手机里，在整个火车途中，他可以听P首歌，所以他想产生一个播放表产生P首歌曲，这个播放表的原则是：</p><p>（1）每首歌都要至少被播放一次</p><p>（2）在两首一样的歌中间，至少有N首其他的歌</p><p>小明想有多少种不同的播放表可以产生，那么给你N、M、P，你来算一下，输出结果取1000000007的余数。</p><ul><li>定义 value(i,j) 为在背包装载体积为 i,物品为第 1 到 j 个的情况下,背包的最大价值<br>value(v,sum(m[i])) 即为所求<br>可以把空间复杂度从 O(nv) 降到 O(v)<br>状态转移方程:<br>value(i,j) = |-&gt; max(value(i-w[j],j-1)+s[j],value(i-1,j-1) (i-w[j] &gt;= 0)<pre><code>|-&gt; value(i-1,j-1) (i-w[j] &lt; 0)</code></pre></li></ul><p><strong>进程，线程区别</strong></p><ul><li>1）含义<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li><li>2）区别<br>（1）一个程序至少有一个进程，一个进程至少有一个线程. （2）线程的划分尺度小于进程，使得多线程程序的并发性高。<br>（3）进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>（4）线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>（5）从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</li></ul><p><strong>int cast到byte(*)</strong><br>笔试题</p><pre><code>public class leftshift_operator {public static void main(String args[]){    byte x = 64;    int i;    byte y;    i = x&lt;&lt;2;    y = (byte)(x&lt;&lt;2);    System.out.print(i+ &quot; &quot; +y);}}</code></pre><ul><li>输出 256 0</li><li>0是因为 x 01000000 被 cast 到  int 32位 00000000000000000000000001000000<br>左移2位 00000000000000000000000100000000, 最低8位 00000000</li></ul><p><strong>CMS缺点</strong></p><ul><li>CMS收集器对CPU资源非常敏感<pre><code>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，为了解决这种情况，虚拟机提供了一种“增量式并发收集器”</code></pre>的CMS收集器变种， 就是在并发标记和并发清除的时候让GC线程和用户线程交替运行，尽量减少GC<br>线程独占资源的时间，这样整个垃圾收集的过程会变长，但是对用户程序的影响会减少。（效果不明显，不推荐）</li><li>CMS处理器无法处理浮动垃圾<pre><code>CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾”</code></pre></li><li>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发full gc。</li><li>需要更大的堆空间</li></ul><p><strong>++操作符和乘除</strong><br>下列代码执行后的变量num3的值?</p><pre><code>public static void main(String[] args) {int num1 = 6, num2 = 7, num3 = 12;if (++num1 == num2)    num3 = ++num3 * 3;System.out.println(num3);}</code></pre><ul><li>39, 先++num3 ,再乘3</li></ul><p><strong>某网络的IP地址空间为10.0.17.0/24，采用等长子网划分，子网掩码为255.255.255.240，则该网络的最大子网个数、每个子网内的最大分配地址个数?(*)</strong><br>笔试常考</p><ul><li>240, 11110000</li><li>2^4=16 最大子网个数</li><li>2^4-2=14 子网最大分配地址个数</li></ul><p><strong>Class, newInstance, 默认构造器</strong></p><pre><code>public class whatTheHell {public whatTheHell() {}private String a;private Integer b;public whatTheHell(String a, Integer b) {    this.a = a;    this.b = b;}public String getA() {    return a;}public void setA(String a) {    this.a = a;}public Integer getB() {    return b;}public void setB(Integer b) {    this.b = b;}public static void main(String[] args) {    Class&lt;whatTheHell&gt; whatTheHellClass = whatTheHell.class;    try {        whatTheHell whatTheHell = whatTheHellClass.newInstance();        System.out.println(whatTheHell == null ? true : false);    } catch (InstantiationException e) {        e.printStackTrace();    } catch (IllegalAccessException e) {        e.printStackTrace();    }}}</code></pre><ul><li>不提供默认构造器会报错。</li></ul><p><strong>若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别0和3。当从队列中删除一个元素，再加入两 个元素后，rear和front的值分别为?</strong></p><ul><li>2,4</li><li>删除一个元素后，队首指针要加1，front=（front+1）%6，结果为4，每加入一个元素队尾指针加一，即real=（real+1）%6，加入两个元素后变为2</li></ul><p><strong>棵完全二叉树有600个节点，那么它的叶子节点有</strong></p><ul><li>(600+1)/2=300</li></ul><p><strong>this, super</strong></p><ul><li>this()函数主要应用于同一类中从某个构造函数调用另一个重载版的构造函数。this()只能用在构造函数中，并且也只能在第一行。所以在同一个构造函数中this()和super()不能同时出现。</li><li>super()函数在子类构造函数中调用父类的构造函数时使用，而且必须要在构造函数的第一行</li></ul><p><strong>java中，当实例化子类对象时，如果有以下几个会被加载，那么加载的顺序是什么?(*)</strong><br>笔试常考</p><ul><li>(1)父类静态代码块</li><li>(2)子类静态代码块</li><li>(3)父类非静态代码块</li><li>(4)父类构造函数</li><li>(5)子类非静态代码块</li><li>(6)子类构造函数</li></ul><p><strong>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个?</strong></p><ul><li>顶点数 =  所有节点度数 +1</li><li>2+1+2+x = （3x2 + 2x1 + 1x2 + 0 x X） + 1</li><li>x = 6</li></ul><p><strong>forward和redirect区别</strong></p><ul><li>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li><li>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</li><li>redirect 默认302暂时跳转</li></ul><p><strong>操作系统，临时抱佛脚</strong></p><ul><li><a href="https://blog.csdn.net/csdn_chai/article/details/78002202" target="_blank" rel="noopener">https://blog.csdn.net/csdn_chai/article/details/78002202</a></li><li><a href="https://zhuanlan.zhihu.com/p/23755202" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23755202</a></li></ul><p><strong>前缀（波兰），后缀（逆波兰），中缀表达式</strong></p><ul><li><a href="https://blog.csdn.net/antineutrino/article/details/6763722" target="_blank" rel="noopener">https://blog.csdn.net/antineutrino/article/details/6763722</a></li></ul><p><strong>BigInteger, BigDecimal</strong></p><ul><li><a href="https://blog.csdn.net/zhongkelee/article/details/52289163" target="_blank" rel="noopener">https://blog.csdn.net/zhongkelee/article/details/52289163</a></li></ul><p><strong>在一个C类地址段内，需要将网络划分为 7个子网，每个子网有15个主机，则可以使用哪个子网掩码？(*)</strong></p><ul><li>255.255.255.224</li><li>IP地址的结构是：网络号+主机号, 划分子网是从主机号中抽取几位进行子网划分，c类地址前24位为网络号</li><li>224, 11100000</li><li>2^3=8&gt;7</li><li>2^5=32&gt;15</li></ul><p><strong>Linux 网络相关命令</strong></p><ul><li><p>ping是使用的ICMP协议，是IP层协议，但是端口是应用层的，所以它只能判断能够访问ip，不能判断端口</p></li><li><p>ifconfig是查看本机的网络设置，IP，子网掩码等</p></li><li><p>telnet是应用层的，可以判端口访问情况</p></li><li><p>netstat显示网络信息，如网络连接，路由表，接口状态</p></li></ul><p><strong>递归时间复杂度</strong><br> <strong>master 公式</strong><br><strong>T(N) = a*T(N/b) + O(N^d)</strong></p><p>估计递归问题复杂度的通式，只要复杂度符合以下公式，都可以套用此公式计算时间复杂度</p><p>例子：递归方式查找数组最大值 T(N) = 2*T(N/2) + O(1)</p><p>T(N)：样本量为 N 的情况下，时间复杂度<br>N：父问题的样本量<br>a：子问题发生的次数（父问题被拆分成了几个子问题，不需要考虑递归调用，只考虑单层的父子关系）<br>b：被拆成子问题，子问题的样本量（子问题所需要处理的样本量），比如 N 被拆分成两半，所以子问题样本量为 N/2<br>O(N^d)：剩余操作的时间复杂度，除去调用子过程之外，剩下问题所需要的代价（常规操作则为 O(1)）</p><ul><li>log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))</li><li>log(b,a) = d -&gt; 复杂度为O(N^d * logN)</li><li>log(b,a) &lt; d -&gt; 复杂度为O(N^d)</li></ul><p><strong>Java变量命名(*)</strong></p><ul><li>$, _,  字母开头</li><li>不能是数字开头</li><li>不能使关键字private, final…</li></ul><p><strong>查看linux操作系统磁盘空间命令</strong></p><ul><li>df</li></ul><p><strong>设有一个含有13个元素的Hash表(0~12),Hash函数是:H(key)=key % 13,其中%是求余数运算。用线性探查法解决冲突,则对于序列(2、８、31、20、19、18、53、27),18应放在第几号格中?</strong></p><ul><li>求出18之前的序列余数为2、8、5、7、6，H(18)=5与之前的冲突，直接向后移，6、7、8都有元素，因此放在9号上</li></ul><p><strong>如果一个二叉树中任意节点的左右子树“高度”相差不超过 1，我们称这个二叉树为“高度平衡二叉树”。根据如上定义，一个高度为 8 的高度平衡二叉树至少有几个节点？</strong></p><ul><li>54</li><li>类似斐波那契数列的递推公式。Sn = Sn-1 + Sn-2 + 1,初值，S1 =1，S2 =2</li><li>1    2   4   7       12  20  33  54</li></ul><p><strong>某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？(*)</strong></p><ul><li>11111111.11111111.11111111.?</li><li>2^3=8, 至少3个1</li><li>2^5=32, 32-网关-广播=30&gt;26</li><li>11100000</li><li>224</li><li>255.255.255.224</li></ul>]]></content>
    
    <summary type="html">
    
      面试
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>情话</title>
    <link href="http://yoursite.com/2019/10/20/%E6%83%85%E8%AF%9D/"/>
    <id>http://yoursite.com/2019/10/20/情话/</id>
    <published>2019-10-20T13:13:50.000Z</published>
    <updated>2019-11-15T15:14:18.309Z</updated>
    
    <content type="html"><![CDATA[<center>情话</center><h3 id="20191020"><a href="#20191020" class="headerlink" title="20191020"></a>20191020</h3><hr><p>我想你一定很忙，<br>所以你只要看前三个字就好了。</p><hr><h3 id="20191023"><a href="#20191023" class="headerlink" title="20191023"></a>20191023</h3><hr><p>林深时见鹿，<br>海蓝时见鲸，<br>梦醒时见你。</p><hr><h3 id="20191024"><a href="#20191024" class="headerlink" title="20191024"></a>20191024</h3><hr><p>月亮很亮，亮也没用，没用也亮。<br>我喜欢你，喜欢也没用，没用也喜欢。</p><hr><h3 id="20191025"><a href="#20191025" class="headerlink" title="20191025"></a>20191025</h3><hr><p>直到今天我才知道，我的人生之所以漂泊就是在向你漂流而去。</p><hr><h3 id="20191030"><a href="#20191030" class="headerlink" title="20191030"></a>20191030</h3><hr><p>不乱于心，不困于情，<br>不畏将来，不念过往，<br>如此，安好。</p><hr><h3 id="20191031"><a href="#20191031" class="headerlink" title="20191031"></a>20191031</h3><hr><p>这个世界乱糟糟的 而你干干净净 可以悬在我的心上 作太阳和月亮.</p><hr><h3 id="20191101"><a href="#20191101" class="headerlink" title="20191101"></a>20191101</h3><hr><p>我希望 我是你想藏在口袋里的欢喜</p><hr><h3 id="20191106"><a href="#20191106" class="headerlink" title="20191106"></a>20191106</h3><hr><p>我喜欢你，不需要太多言语，只想和你静静地呆在一起，让你出现在我的眼睛里。</p><hr><h3 id="20191107"><a href="#20191107" class="headerlink" title="20191107"></a>20191107</h3><hr><p>旅行时最幸福的可能是，你在拍景，有人在拍你。。</p><hr><h3 id="20191112"><a href="#20191112" class="headerlink" title="20191112"></a>20191112</h3><hr><p>风也吹过，雨也来过，在阴冷的天气抱着你躲进被窝，耳鬓厮磨。雪也下过，晴也停过，在暖和的日子牵着你漫步悠悠，安然喜乐。一年四季想陪你度过，世间琐事想与你做，此生也只想同你尝尽烟火。</p><hr><h3 id="20191113"><a href="#20191113" class="headerlink" title="20191113"></a>20191113</h3><hr><p>但行好事，莫问前程。</p><hr><h3 id="20191115"><a href="#20191115" class="headerlink" title="20191115"></a>20191115</h3><hr><p>我们各自努力，你抽空爱我。</p><hr><h3 id="20191115-1"><a href="#20191115-1" class="headerlink" title="20191115"></a>20191115</h3><hr><p>谢谢你，</p><p>在这世界的角落</p><p>找到了我。</p><hr><h3 id="20191115-2"><a href="#20191115-2" class="headerlink" title="20191115"></a>20191115</h3><hr><hr>]]></content>
    
    <summary type="html">
    
      相信坚持的力量
    
    </summary>
    
    
      <category term="情话" scheme="http://yoursite.com/categories/%E6%83%85%E8%AF%9D/"/>
    
    
      <category term="情话" scheme="http://yoursite.com/tags/%E6%83%85%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础(二)</title>
    <link href="http://yoursite.com/2019/10/16/Java%20%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/10/16/Java 基础(二)/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-06T11:37:40.386Z</updated>
    
    <content type="html"><![CDATA[<center>    进制</center><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><blockquote><p>位权</p></blockquote><blockquote><p>补码表示法</p></blockquote><blockquote><table><tr><td bgcolor="#a0f0ff">源码表示法</td></tr></table></blockquote><h3 id="十进制与二进制的转换"><a href="#十进制与二进制的转换" class="headerlink" title="十进制与二进制的转换"></a>十进制与二进制的转换</h3><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>位运算包括移位运算和逻辑运算</p></blockquote><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">4</span>; <span class="comment">//二进制为 100</span></span><br><span class="line">                a = a &gt;&gt; <span class="number">2</span>; <span class="comment">// 二进制为 001</span></span><br><span class="line">                System.out.println(a);</span><br><span class="line">                a= a &lt;&lt; <span class="number">3</span>; <span class="comment">// 二进制为1000</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序输出</p><blockquote><p>1</p><p>8</p><blockquote><p>Process finished with exit code 0</p></blockquote></blockquote></blockquote><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><table><thead><tr><th align="center">逻辑运算</th><th align="center">运算符</th><th align="center">规则</th></tr></thead><tbody><tr><td align="center">按位与</td><td align="center">&amp;</td><td align="center">两位都为1才为1</td></tr><tr><td align="center">按位或</td><td align="center">&#124;</td><td align="center">两位都为1才为1</td></tr><tr><td align="center">按位取反</td><td align="center">~</td><td align="center">1变为0,0变为1</td></tr><tr><td align="center">按位异或</td><td align="center">^</td><td align="center">相异为真，相同为假</td></tr></tbody></table><table><tr><td bgcolor="a0f0ff">    如果在MarkDown输入特殊字符可以使用字符对应的ASCII值    例如 | 对应的ASCII为124;</td></tr></table><h2 id="字符的编码与乱码"><a href="#字符的编码与乱码" class="headerlink" title="字符的编码与乱码"></a>字符的编码与乱码</h2><h3 id="常用的非Unicode编码"><a href="#常用的非Unicode编码" class="headerlink" title="常用的非Unicode编码"></a>常用的非Unicode编码</h3><h4 id="1-ASCII编码"><a href="#1-ASCII编码" class="headerlink" title="1.ASCII编码"></a>1.ASCII编码</h4><blockquote><p>American Standard Code for Information Interchange(美国信息互换标准代码)</p><blockquote><p>由一个byte构成，0 ~ 127,127转换为二进制数为最大的7位二进制数。</p></blockquote></blockquote><h4 id="2-ISO-8859-1-Latin-1"><a href="#2-ISO-8859-1-Latin-1" class="headerlink" title="2.ISO 8859-1(Latin-1)"></a>2.ISO 8859-1(Latin-1)</h4><blockquote><p>128 ~ 159 表示控制字符</p><p>160 ~ 255 表示西欧字符 </p></blockquote><h4 id="3-Windows-1252"><a href="#3-Windows-1252" class="headerlink" title="3.Windows-1252"></a>3.Windows-1252</h4><blockquote><p>用于替换ISO 8859-1 因为出现较早没有欧元等符号，二者的区别主要在于128 ~ 159</p></blockquote><h4 id="4-GB2312"><a href="#4-GB2312" class="headerlink" title="4.GB2312"></a>4.GB2312</h4><blockquote><p>主要是针对简体中文常见字符，包括7000个汉字和一些罕用词和繁体字。</p></blockquote><h4 id="5-GBK"><a href="#5-GBK" class="headerlink" title="5.GBK"></a>5.GBK</h4><blockquote><p>GBK是建立在GB2312的基础上，向下兼容了GB2312，GBK增加了14000多个汉字。</p></blockquote><h4 id="6-GB18030"><a href="#6-GB18030" class="headerlink" title="6.GB18030"></a>6.GB18030</h4><blockquote><p>向下兼容了GBK，共计76000多个字符，包括了很多少数民族字符，以及中日韩统一字符。</p></blockquote><h4 id="7-Big5"><a href="#7-Big5" class="headerlink" title="7.Big5"></a>7.Big5</h4><blockquote><p>是针对繁体中文的，港台地区使用。</p></blockquote><h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><blockquote><p>每个字符用4个字节表示，非常浪费空间</p></blockquote><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><blockquote><p>使用变长字节表示</p></blockquote><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><blockquote><p>使用变长字节表示，每个字节使用的字节个数与其Unicode编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多，使用的字节为1 ~ 4字节不等。</p></blockquote><table><tr><td bgcolor="#a0f0ff">    编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子。</td></tr></table><h2 id="编码错误的原因"><a href="#编码错误的原因" class="headerlink" title="编码错误的原因"></a>编码错误的原因</h2><h3 id="1-解析错误"><a href="#1-解析错误" class="headerlink" title="1.解析错误"></a>1.解析错误</h3><h3 id="2-错误的解析和编码转换"><a href="#2-错误的解析和编码转换" class="headerlink" title="2.错误的解析和编码转换"></a>2.错误的解析和编码转换</h3><h3 id="char的真正含义"><a href="#char的真正含义" class="headerlink" title="char的真正含义"></a>char的真正含义</h3><blockquote><p>char本质是一个固定占用两个字节的无符号正整数，</p></blockquote>]]></content>
    
    <summary type="html">
    
      基础的数据类型
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven使用</title>
    <link href="http://yoursite.com/2019/10/16/Maven/"/>
    <id>http://yoursite.com/2019/10/16/Maven/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-09T09:10:42.589Z</updated>
    
    <content type="html"><![CDATA[<center>   Maven</center><h3 id="1-Maven-的配置"><a href="#1-Maven-的配置" class="headerlink" title="1. Maven 的配置"></a>1. Maven 的配置</h3><blockquote><ol><li>环境变量配置<blockquote><p>MAVEN_HOME:F:\Maven\apache-maven-3.5.3-bin\apache-maven-3.5.3</p></blockquote></li></ol></blockquote><blockquote><ol start="2"><li>PATH 配置<blockquote><p>%MAVEN_HOME%\bin</p></blockquote></li></ol></blockquote><h3 id="2-Maven的生命周期"><a href="#2-Maven的生命周期" class="headerlink" title="2.Maven的生命周期"></a>2.Maven的生命周期</h3><blockquote><p>Maven有三套相互独立的生命周期，分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。</p></blockquote><p>1.clean生命周期：清理项目，包含三个phase。</p><ul><li><p>pre-clean：执行清理前需要完成的工作</p></li><li><p>clean：清理上一次构建生成的文件</p></li><li><p>post-clean：执行清理后需要完成的工作</p></li></ul><p>2.default生命周期：构建项目，重要的phase如下。</p><ul><li>validate：验证工程是否正确，所有需要的资源是否可用。</li><li>compile：编译项目的源代码。</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>Package：把已编译的代码打包成可发布的格式，比如jar。</li><li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li><li>Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li></ul><p>3.site生命周期：建立和发布项目站点，phase如下</p><ul><li><p>pre-site：生成项目站点之前需要完成的工作</p></li><li><p>site：生成项目站点文档</p></li><li><p>post-site：生成项目站点之后需要完成的工作</p></li><li><p>site-deploy：将项目站点发布到服务器</p></li></ul><h3 id="3-配置Maven仓库"><a href="#3-配置Maven仓库" class="headerlink" title="3. 配置Maven仓库"></a>3. 配置Maven仓库</h3><p>3.1 本地仓库配置到指定路径</p><blockquote><p>在maven解压文件中，conf目录中修改settings.xml文件。<br>可以添加新的仓库路径<localrepository>D:Programming\maven-3.5.2\repository</localrepository><br>3.2 配置中央仓库指定阿里的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;nexus-aliyun&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><h3 id="4-配置Idea使用自己安装的Maven"><a href="#4-配置Idea使用自己安装的Maven" class="headerlink" title="4.配置Idea使用自己安装的Maven"></a>4.配置Idea使用自己安装的Maven</h3><p><img src="https://i.loli.net/2019/10/08/jUhJqWRYrISV37u.png" alt="20191008123630"></p><h3 id="5-Maven如何将自己下载的jar包安装到本地仓库"><a href="#5-Maven如何将自己下载的jar包安装到本地仓库" class="headerlink" title="5. Maven如何将自己下载的jar包安装到本地仓库"></a>5. Maven如何将自己下载的jar包安装到本地仓库</h3><blockquote><p>示例： 想要添加Oracle驱动包时，Maven的pom.xml总是报Missing artifact com.oracle:ojdbc14:jar:10.2.0.1.0错。</p></blockquote><p>解决办法：</p><blockquote><p><a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html" target="_blank" rel="noopener">oracle官网</a>  下载你所需要的oraclejar包</p></blockquote><blockquote><p>将jar放在盘符下</p></blockquote><blockquote><p>cmd 命令下运行</p><blockquote><p>  mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.1.0 -Dpackaging=jar -Dfile=F:ojdbc14.jar</p><blockquote><p>-Dfile 是你的jar包的路径</p></blockquote></blockquote></blockquote><blockquote><p>pom.xml文件中输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;10.2.0.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="6-Maven官网"><a href="#6-Maven官网" class="headerlink" title="6. Maven官网"></a>6. Maven官网</h3><blockquote><p><a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven官网</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Maven的使用
    
    </summary>
    
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>网站清单</title>
    <link href="http://yoursite.com/2019/10/16/%E7%BD%91%E7%AB%99%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2019/10/16/网站清单/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-15T14:40:55.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有趣的学习网站"><a href="#有趣的学习网站" class="headerlink" title="有趣的学习网站"></a>有趣的学习网站</h2><table><thead><tr><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">git学习网站</a></td><td><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener">图说设计模式</a></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h2><table><thead><tr><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td><a href="https://oktools.net/" target="_blank" rel="noopener">格式化工具</a></td><td></td><td></td></tr></tbody></table><h2 id="常用官网"><a href="#常用官网" class="headerlink" title="常用官网"></a>常用官网</h2><table><thead><tr><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td><a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven</a></td><td><a href="https://spring.io/" target="_blank" rel="noopener">Spring</a></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      网站清单
    
    </summary>
    
    
      <category term="网站清单" scheme="http://yoursite.com/categories/%E7%BD%91%E7%AB%99%E6%B8%85%E5%8D%95/"/>
    
    
      <category term="网站清单" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Java项目</title>
    <link href="http://yoursite.com/2019/10/16/%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/10/16/项目/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-20T09:55:51.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-CS-Notes"><a href="#1-CS-Notes" class="headerlink" title="1.CS-Notes"></a>1.CS-Notes</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li><strong>Star</strong>:  69.8k</li><li><strong>介绍</strong>: 技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li></ul><h3 id="2-toBeTopJavaer"><a href="#2-toBeTopJavaer" class="headerlink" title="2.toBeTopJavaer"></a>2.toBeTopJavaer</h3><ul><li><strong>Github 地址：</strong><a href="https://github.com/hollischuang/toBeTopJavaer" target="_blank" rel="noopener">https://github.com/hollischuang/toBeTopJavaer</a></li><li><strong>Star</strong>:  4.7k</li><li><strong>介绍</strong>: To Be Top Javaer - Java工程师成神之路。</li></ul><h3 id="3-p3c"><a href="#3-p3c" class="headerlink" title="3.p3c"></a>3.p3c</h3><ul><li><strong>Github 地址：</strong> <a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">https://github.com/alibaba/p3c</a></li><li><strong>Star</strong>:  16.6k</li><li><strong>介绍</strong>: Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！</li></ul><h3 id="4-SpringCloudLearning"><a href="#4-SpringCloudLearning" class="headerlink" title="4.SpringCloudLearning"></a>4.SpringCloudLearning</h3><ul><li><strong>Github 地址：</strong> <a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">https://github.com/forezp/SpringCloudLearning</a></li><li><strong>Star</strong>:  8.7k</li><li><strong>介绍</strong>: 史上最简单的Spring Cloud教程源码。</li></ul><h3 id="5-dubbo"><a href="#5-dubbo" class="headerlink" title="5.dubbo"></a>5.dubbo</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">https://github.com/apache/dubbo</a></li><li><strong>star</strong>: 27.6 k</li><li><strong>介绍</strong>: Apache Dubbo是一个基于Java的高性能开源RPC框架。</li></ul><h3 id="6-jeecg-boot"><a href="#6-jeecg-boot" class="headerlink" title="6.jeecg-boot"></a>6.jeecg-boot</h3><ul><li><strong>Github地址</strong>： <a href="https://github.com/zhangdaiscott/jeecg-boot" target="_blank" rel="noopener">https://github.com/zhangdaiscott/jeecg-boot</a></li><li><strong>star</strong>: 3.3 k</li><li><strong>介绍</strong>: 一款基于代码生成器的JAVA快速开发平台！全新架构前后端分离：SpringBoot 2.x，Ant Design&amp;Vue，Mybatis，Shiro，JWT。强大的代码生成器让前后端代码一键生成，无需写任何代码，绝对是全栈开发福音！！ JeecgBoot的宗旨是提高UI能力的同时,降低前后分离的开发成本，JeecgBoot还独创在线开发模式，No代码概念，一系列在线智能开发：在线配置表单、在线配置报表、在线设计流程等等。</li></ul><h3 id="7-advanced-java"><a href="#7-advanced-java" class="headerlink" title="7.advanced-java"></a>7.advanced-java</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li><li><strong>Star</strong>: 24.2k</li><li><strong>介绍</strong>: 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习。</li></ul><h3 id="8-FEBS-Shiro"><a href="#8-FEBS-Shiro" class="headerlink" title="8.FEBS-Shiro"></a>8.FEBS-Shiro</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/wuyouzhuguli/FEBS-Shiro" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Shiro</a></li><li><strong>Star</strong>: 2.6k</li><li><strong>介绍</strong>: Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。预览地址：<a href="http://49.234.20.223:8080/login。" target="_blank" rel="noopener">http://49.234.20.223:8080/login。</a></li></ul><h3 id="9-SpringAll"><a href="#9-SpringAll" class="headerlink" title="9.SpringAll"></a>9.SpringAll</h3><ul><li><strong>Github 地址</strong>: <a href="https://github.com/wuyouzhuguli/SpringAll" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll</a></li><li><strong>Star</strong>: 5.4k</li><li><strong>介绍</strong>: 循序渐进，学习Spring Boot、Spring Boot &amp; Shiro、Spring Cloud、Spring Security &amp; Spring Security OAuth2，博客Spring系列源码。</li></ul><h3 id="10-JavaGuide"><a href="#10-JavaGuide" class="headerlink" title="10.JavaGuide"></a>10.JavaGuide</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li><li><strong>Star</strong>:  47.2k</li><li><strong>介绍</strong>: 【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li></ul><h3 id="11-vhr"><a href="#11-vhr" class="headerlink" title="11.vhr"></a>11.vhr</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><strong>Star</strong>:  4.9k</li><li><strong>介绍</strong>: 微人事是一个前后端分离的人力资源管理系统，项目采用SpringBoot+Vue开发。</li></ul><h3 id="12-tutorials"><a href="#12-tutorials" class="headerlink" title="12. tutorials"></a>12. tutorials</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/eugenp/tutorials" target="_blank" rel="noopener">https://github.com/eugenp/tutorials</a></li><li><strong>star</strong>: 15.4 k</li><li><strong>介绍</strong>:  该项目是一系列小而专注的教程 - 每个教程都涵盖 Java 生态系统中单一且定义明确的开发领域。 当然，它们的重点是 Spring Framework  -  Spring，Spring Boot 和 Spring Securiyt。 除了 Spring 之外，还有以下技术：核心 Java，Jackson，HttpClient，Guava。</li></ul><h3 id="13-EasyScheduler"><a href="#13-EasyScheduler" class="headerlink" title="13.EasyScheduler"></a>13.EasyScheduler</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/analysys/EasyScheduler" target="_blank" rel="noopener">https://github.com/analysys/EasyScheduler</a></li><li><strong>star</strong>: 1.1 k</li><li><strong>介绍</strong>:  Easy Scheduler是一个分布式工作流任务调度系统，主要解决“复杂任务依赖但无法直接监控任务健康状态”的问题。Easy Scheduler以DAG方式组装任务，可以实时监控任务的运行状态。同时，它支持重试，重新运行等操作… 。<a href="https://analysys.github.io/easyscheduler_docs_cn/" target="_blank" rel="noopener">https://analysys.github.io/easyscheduler_docs_cn/</a></li></ul><h3 id="14-thingsboard"><a href="#14-thingsboard" class="headerlink" title="14.thingsboard"></a>14.thingsboard</h3><ul><li><strong>Github 地址</strong>：<a href="https://github.com/thingsboard/thingsboard" target="_blank" rel="noopener">https://github.com/thingsboard/thingsboard</a></li><li><strong>star</strong>: 3.7 k</li><li><strong>介绍</strong>:  开源物联网平台 - 设备管理，数据收集，处理和可视化。 <a href="https://thingsboard.io/" target="_blank" rel="noopener">https://thingsboard.io</a></li></ul><h3 id="15-mall-learning"><a href="#15-mall-learning" class="headerlink" title="15.mall-learning"></a>15.mall-learning</h3><ul><li><strong>Github 地址</strong>: <a href="https://github.com/macrozheng/mall-learning" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning</a></li><li><strong>star</strong>: 0.6 k</li><li><strong>介绍</strong>:  mall学习教程，架构、业务、技术要点全方位解析。mall项目（16k+star）是一套电商系统，使用现阶段主流技术实现。 涵盖了SpringBoot2.1.3、MyBatis3.4.6、Elasticsearch6.2.2、RabbitMQ3.7.15、Redis3.2、Mongodb3.2、Mysql5.7等技术，采用Docker容器化部署。 <a href="https://github.com/macrozheng/mall" target="_blank" rel="noopener">https://github.com/macrozheng/mall</a></li></ul><h3 id="16-flink"><a href="#16-flink" class="headerlink" title="16. flink"></a>16. flink</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/apache/flink" target="_blank" rel="noopener">https://github.com/apache/flink</a></li><li><strong>star</strong>: 9.3 k</li><li><strong>介绍</strong>: Apache Flink是一个开源流处理框架，具有强大的流和批处理功能。</li></ul><h3 id="17-spring-cloud-kubernetes"><a href="#17-spring-cloud-kubernetes" class="headerlink" title="17.spring-cloud-kubernetes"></a>17.spring-cloud-kubernetes</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/spring-cloud/spring-cloud-kubernetes" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-kubernetes</a></li><li><strong>star</strong>: 1.4 k</li><li><strong>介绍</strong>: Kubernetes 集成 Spring Cloud Discovery Client, Configuration, etc…</li></ul><h3 id="18-springboot-learning-example"><a href="#18-springboot-learning-example" class="headerlink" title="18.springboot-learning-example"></a>18.springboot-learning-example</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/JeffLi1993/springboot-learning-example" target="_blank" rel="noopener">https://github.com/JeffLi1993/springboot-learning-example</a></li><li><strong>star</strong>: 10.0 k</li><li><strong>介绍</strong>: spring boot 实践学习案例，是 spring boot 初学者及核心技术巩固的最佳实践。</li></ul><h3 id="19-canal"><a href="#19-canal" class="headerlink" title="19.canal"></a>19.canal</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">https://github.com/alibaba/canal</a></li><li><strong>star</strong>: 9.3 k</li><li><strong>介绍</strong>: 阿里巴巴 MySQL binlog 增量订阅&amp;消费组件。</li></ul><h3 id="20-react-native-device-info"><a href="#20-react-native-device-info" class="headerlink" title="20.react-native-device-info"></a>20.react-native-device-info</h3><ul><li><strong>Github地址</strong>：<a href="https://github.com/react-native-community/react-native-device-info" target="_blank" rel="noopener">https://github.com/react-native-community/react-native-device-info</a></li><li><strong>star</strong>: 4.0 k</li><li><strong>介绍</strong>: React Native iOS和Android的设备信息。</li></ul>]]></content>
    
    <summary type="html">
    
      Java项目
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类的基础</title>
    <link href="http://yoursite.com/2019/10/16/%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/10/16/类的基础(一)/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-07T08:09:36.420Z</updated>
    
    <content type="html"><![CDATA[<center>    面向对象</center><h2 id="类的基本概念"><a href="#类的基本概念" class="headerlink" title="类的基本概念"></a>类的基本概念</h2><blockquote><p>类是函数的容器，但类更多表示的是自定义的数据类型。</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>Java中可以定义没有方法体的方法，该方法由其子类来具体的实现。<br>该没有方法体的方法我们称之为抽象方法，含有抽象方法的类我们称之为抽象类。</p></blockquote><p>###抽象方法的特点</p><ul><li>只有方法头没有方法体的方法称之为抽象方法。（即只有方法的声明，没有方法的实现）</li><li>抽象方法用abstract关键字来修饰。</li><li>抽象方法代表一种不确定的操作或行为。（由子类去具体实现）</li><li>抽象方法不能被调用。</li></ul><h3 id="函数容器"><a href="#函数容器" class="headerlink" title="函数容器"></a>函数容器</h3><blockquote><table> <tr><td bgcolor="#00ffff">不在同一包下，无法访问父类默认的构造方法</td> </tr></table></blockquote><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><blockquote><p>static表示类方法</p><blockquote><p>类变量 就是静态变量 声明类变量<br>通过类名直接调用</p></blockquote></blockquote><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><blockquote><p>通过实例或者对象调用</p><blockquote><p> 实例方法是表示具体的实例可以进行的操作。<br>实例<br>实例变量表示具体的实例所具有的属性<br>有一种对象只叫对象，有一种对象叫实例化对象（实例）。</p></blockquote><p>对象 </p></blockquote>]]></content>
    
    <summary type="html">
    
      面向对象
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java书单</title>
    <link href="http://yoursite.com/2019/10/16/Java%E4%B9%A6%E5%8D%95/"/>
    <id>http://yoursite.com/2019/10/16/Java书单/</id>
    <published>2019-10-16T13:13:50.000Z</published>
    <updated>2019-10-20T09:48:48.254Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#java">Java</a><ul><li><a href="#基础">基础</a></li><li><a href="#并发">并发</a></li><li><a href="#jvm">JVM</a></li><li><a href="#java8-新特性">Java8 新特性</a></li><li><a href="#代码优化">代码优化</a></li></ul></li><li><a href="#网络">网络</a></li><li><a href="#操作系统">操作系统</a></li><li><a href="#数据结构与算法">数据结构与算法</a></li><li><a href="#数据库">数据库</a></li><li><a href="#系统设计">系统设计</a><ul><li><a href="#设计模式">设计模式</a></li><li><a href="#常用框架">常用框架</a></li><li><a href="#网站架构">网站架构</a></li><li><a href="#软件底层">软件底层</a></li></ul></li><li><a href="#其他">其他</a></li></ul><!-- /TOC --><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a>(推荐，豆瓣评分 8.7，1.0K+人评价)：  可以说是我的 Java 启蒙书籍了，特别适合新手读当然也适合我们用来温故 Java 知识点。</li><li><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java 核心技术卷 1+卷 2》</a>（推荐）: 很棒的两本书，建议有点 Java 基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点，是两本适合放在自己身边的好书。</li><li><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA 网络编程 第 4 版》</a>：  可以系统的学习一下网络的一些概念以及网络编程在 Java 中的使用。</li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java 编程思想 (第 4 版)》</a>（推荐，豆瓣评分 9.1，3.2K+人评价）：大部分人称之为Java领域的圣经，但我不推荐初学者阅读，有点劝退的味道。稍微有点基础后阅读更好。</li><li><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a>（推荐，豆瓣评分 8.2，0.1K+人评价）：O’Reilly 家族书，性能调优的入门书，我个人觉得性能调优是每个 Java 从业者必备知识，这本书的缺点就是太老了，但是这本书可以作为一个实战书，尤其是 JVM 调优！不适合初学者。前置书籍：《深入理解 Java 虚拟机》</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><a href="https://book.douban.com/subject/30351286/" target="_blank" rel="noopener">《Java 并发编程之美》</a> （推荐）：2018 年 10 月出版的一本书，个人感觉非常不错，对每个知识点的讲解都很棒。</li><li><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java 并发编程的艺术》</a>（推荐，豆瓣评分 7.2，0.2K+人评价）： 这本书不是很适合作为 Java 并发入门书籍，需要具备一定的 JVM 基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</li><li><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战 Java 高并发程序设计》</a>（推荐,豆瓣评分 8.3）： 书的质量没的说，推荐大家好好看一下。</li><li><a href="https://book.douban.com/subject/30255689/" target="_blank" rel="noopener">《Java 高并发编程详解》</a>（豆瓣评分 7.6）： 2018 年 6 月出版的一本书，内容很详细，但可能又有点过于啰嗦，不过这只是我的感觉。</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机（第 2 版）周志明》</a>（推荐，豆瓣评分 8.9，1.0K+人评价）：建议多刷几遍，书中的所有知识点可以通过 JAVA 运行时区域和 JAVA 的内存模型与线程两个大模块罗列完全。</li><li><a href="https://book.douban.com/subject/26354292/" target="_blank" rel="noopener">《实战 JAVA 虚拟机》</a>（推荐，豆瓣评分 8.0，1.0K+人评价）：作为入门的了解 Java 虚拟机的知识还是不错的。</li></ul><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><ul><li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java 8 实战》</a> （推荐，豆瓣评分 9.2 ）：面向 Java 8 的技能升级，包括 Lambdas、流和函数式编程特性。实战系列的一贯风格让自己快速上手应用起来。Java 8 支持的 Lambda 是精简表达在语法上提供的支持。Java 8 提供了 Stream，学习和使用可以建立流式编程的认知。</li><li><a href="https://book.douban.com/subject/26556574/" target="_blank" rel="noopener">《Java 8 编程参考官方教程》</a> （推荐，豆瓣评分 9.2）：也还不错吧。</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a>（推荐）：豆瓣 9.1 分，重构书籍的开山鼻祖。</li><li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a>（推荐，豆瓣评分 9.0，1.4K+人评价）：本书介绍了在 Java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对 Java 平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</li><li><a href="https://book.douban.com/subject/5442024/" target="_blank" rel="noopener">《代码整洁之道》</a>（推荐，豆瓣评分 9.1）：虽然是用 Java 语言作为例子，全篇都是在阐述 Java 面向对象的思想，但是其中大部分内容其它语言也能应用到。</li><li><strong>阿里巴巴 Java 开发手册（详尽版）</strong> <a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">https://github.com/alibaba/p3c/blob/master/阿里巴巴 Java 开发手册（详尽版）.pdf</a></li><li><strong>Google Java 编程风格指南：</strong> <a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://www.hawstein.com/posts/google-java-style.html</a></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解 HTTP》</a>（推荐,豆瓣评分 8.1 , 1.6K+人评价）： 讲漫画一样的讲 HTTP，很有意思，不会觉得枯燥，大概也涵盖也 HTTP 常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究 HTTP 相关知识的话，读这本书的话应该来说就差不多了。</li><li><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a> （推荐,豆瓣评分 8.6）:如果要全面了解 HTTP 非此书不可！</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜》</a>（推荐，，豆瓣评分 9.1，0.3K+人评价）：本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。全书分为 5 个部分：第一部分着重说明 Linux 的起源及功能，如何规划和安装 Linux 主机；第二部分介绍 Linux 的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell 和管理系统的好帮手 shell 脚本，另外还介绍了文字编辑器 vi 和 vim 的使用方法；第四部分介绍了对于系统安全非常重要的 Linux 账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员 (root) 的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a>（推荐，豆瓣评分 7.9 , 1K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li><li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析：C 语言描述》</a>（推荐，豆瓣评分 8.9，1.6K+人评价）:本书是《Data Structures and Algorithm Analysis in C》一书第 2 版的简体中译本。原书曾被评为 20 世纪顶尖的 30 部计算机著作之一，作者 Mark Allen Weiss 在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界 500 余所大学用作教材。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（推荐，豆瓣评分 8.4，0.6K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li><li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：Java 语言描述，算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。书的内容非常多，可以说是 Java 程序员的必备书籍之一了。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：mysql 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis 实战》</a>：如果你想了解 Redis 的一些概念性知识的话，这本书真的非常不错。</li><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a>（推荐，豆瓣评分 8.5，0.5K+人评价）：也还行吧！</li><li><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="noopener">《MySQL 技术内幕-InnoDB 存储引擎》</a>（推荐，豆瓣评分 8.7）：了解 InnoDB 存储引擎底层原理必备的一本书，比较深入。</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式 : 可复用面向对象软件的基础》 </a> （推荐，豆瓣评分 9.1）：设计模式的经典！</li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式（中文版）》</a> （推荐，豆瓣评分 9.2）：相当赞的一本设计模式入门书籍。用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更（对的，连需求变更都考虑到了！），并以此逐步推导出良好的设计模式解决办法。</li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul><li><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析 Java Web 技术内幕》</a>：  感觉还行，涉及的东西也蛮多。</li><li><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty 实战》</a>（推荐，豆瓣评分 7.8，92 人评价）：内容很细，如果想学 Netty 的话，推荐阅读这本书！</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从 Paxos 到 Zookeeper》</a>（推荐，豆瓣评分 7.8，0.3K 人评价）：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了 Paxos 和 ZAB 协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解 ZooKeeper，并更好地使用和运维 ZooKeeper。</li><li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring 实战（第 4 版）》</a>（推荐，豆瓣评分 8.3，0.3K+人评价）：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于 Spring 的新华字典，只有一些基本概念的介绍和示例，涵盖了 Spring 的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习 Spring，这才刚刚开始”。</li><li><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ 实战指南》</a>：《RabbitMQ 实战指南》从消息中间件的概念和 RabbitMQ 的历史切入，主要阐述 RabbitMQ 的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝 RabbitMQ 的使用，这本书是你最好的选择；如果你想深入 RabbitMQ 的原理，这本书也是你最好的选择；总之，如果你想玩转 RabbitMQ，这本书一定是最值得看的书之一</li><li><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud 微服务实战》</a>：从时下流行的微服务架构概念出发，详细介绍了 Spring Cloud 针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud 微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li><li><a href="https://book.douban.com/subject/26780404/" target="_blank" rel="noopener">《第一本 Docker 书》</a>：Docker 入门书籍！</li><li><a href="https://book.douban.com/subject/33390560/" target="_blank" rel="noopener">《Spring Boot编程思想（核心篇）》</a>（推荐，豆瓣评分 6.2）：SpringBoot深入书，不适合初学者。书尤其的厚，评分低的的理由是书某些知识过于拖沓，评分高的理由是书中对SpringBoot内部原理讲解很清楚。作者小马哥：Apache Dubbo PMC、Spring Cloud Alibaba项目架构师。B站作者地址：<a href="https://space.bilibili.com/327910845?from=search&amp;seid=17095917016893398636。" target="_blank" rel="noopener">https://space.bilibili.com/327910845?from=search&amp;seid=17095917016893398636。</a></li></ul><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul><li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a>（推荐）:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java 面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a>（推荐）：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li></ul><h3 id="软件底层"><a href="#软件底层" class="headerlink" title="软件底层"></a>软件底层</h3><ul><li><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析 Tomcat》</a>（推荐，豆瓣评分 8.4，0.2K+人评价）：本书深入剖析 Tomcat 4 和 Tomcat 5 中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发 Tomcat 组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li><li><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">《深入理解 Nginx（第 2 版）》</a>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://read.douban.com/ebook/387525/?dcs=subject-rec&dcm=douban&dct=2243615" target="_blank" rel="noopener">《黑客与画家》</a>：这本书是硅谷创业之父，Y Combinator 创始人 Paul Graham 的文集。之所以叫这个名字，是因为作者认为黑客（并非负面的那个意思）与画家有着极大的相似性，他们都是在创造，而不是完成某个任务。</li><li><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="noopener">《图解密码技术》</a>（推荐，豆瓣评分 9.1，0.3K+人评价）：本书以<strong>图配文</strong>的形式，第一部分讲述了密码技术的历史沿革、对称密码、分组密码模式（包括ECB、CBC、CFB、OFB、CTR）、公钥、混合密码系统。第二部分重点介绍了认证方面的内容，涉及单向散列函数、消息认证码、数字签名、证书等。第三部分讲述了密钥、随机数、PGP、SSL/TLS 以及密码技术在现实生活中的应用。关键字：JWT 前置知识、区块链密码技术前置知识。属于密码知识入门书籍。</li></ul>]]></content>
    
    <summary type="html">
    
      Java书单
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>感悟</title>
    <link href="http://yoursite.com/2019/09/28/%E6%84%9F%E6%82%9F/"/>
    <id>http://yoursite.com/2019/09/28/感悟/</id>
    <published>2019-09-28T04:23:32.000Z</published>
    <updated>2019-10-31T03:56:54.336Z</updated>
    
    <content type="html"><![CDATA[<p>#每一天很长，但几十年很短。</p><p>#一个人犯错，是众生的罪，你我皆是同谋者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#每一天很长，但几十年很短。&lt;/p&gt;
&lt;p&gt;#一个人犯错，是众生的罪，你我皆是同谋者。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>开发中常用的简单 Linux 命令</title>
    <link href="http://yoursite.com/2019/09/28/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%20Linux%20%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/28/开发中常用的简单 Linux 命令/</id>
    <published>2019-09-28T04:23:32.000Z</published>
    <updated>2019-11-09T08:33:05.491Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2019/09/27/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/27/排序/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-11-17T13:35:22.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = bubbleSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;temp.length ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+i+<span class="string">"元素"</span> +<span class="string">":"</span>+ temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;array.length-<span class="number">1</span>-i ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp =  selectionSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            System.out.println(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length ; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">            array[minIndex]  = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = insertionSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;temp.length ; i++) &#123;</span><br><span class="line">            System.out.println(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex])&#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span> ] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoaderTest</title>
    <link href="http://yoursite.com/2019/09/27/ClassLoader/"/>
    <id>http://yoursite.com/2019/09/27/ClassLoader/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-10-05T02:22:44.119Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      System.out.println(<span class="string">"current loader"</span> + loader);</span><br><span class="line">      System.out.println(<span class="string">"parent loader"</span> + loader.getParent());</span><br><span class="line">      System.out.println(<span class="string">"grandparent  loader"</span> + loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出内容<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current loadersun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">parent loadersun.misc.Launcher$ExtClassLoader@4554617c</span><br><span class="line">grandparent  loadernull</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>通过以上输出信息。我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在java中无法获得句柄就直接返回null。</p></blockquote>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>爱</title>
    <link href="http://yoursite.com/2019/09/27/%E7%88%B1/"/>
    <id>http://yoursite.com/2019/09/27/爱/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-11-04T08:06:46.688Z</updated>
    
    <content type="html"><![CDATA[<p>爱让我们相见，爱让我们相恋，爱让我们相爱，爱让我们牵挂，让我在有生之年把我全部的爱都送给你!</p>]]></content>
    
    <summary type="html">
    
      想对你讲的一些话
    
    </summary>
    
    
      <category term="每日晚安" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E6%99%9A%E5%AE%89/"/>
    
    
      <category term="爱" scheme="http://yoursite.com/tags/%E7%88%B1/"/>
    
  </entry>
  
  <entry>
    <title>编程基础知识积累</title>
    <link href="http://yoursite.com/2019/09/27/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://yoursite.com/2019/09/27/编程基础知识积累/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-10-04T10:45:56.608Z</updated>
    
    <content type="html"><![CDATA[<center>    编程基础知识积累</center><h1 id="POJO-与-EJB"><a href="#POJO-与-EJB" class="headerlink" title="POJO 与 EJB"></a>POJO 与 EJB</h1><h2 id="POJO是什么？"><a href="#POJO是什么？" class="headerlink" title="POJO是什么？"></a>POJO是什么？</h2><p> POJO（Plain Ordinary Java Object）简单的Java对象。</p><h2 id="EJB-是什么？"><a href="#EJB-是什么？" class="headerlink" title="EJB 是什么？"></a>EJB 是什么？</h2><p> 企业级JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的服务器端可被管理组件。</p>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="编程习惯" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF/"/>
    
    
      <category term="编程习惯" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础（一）</title>
    <link href="http://yoursite.com/2019/09/27/Java%20%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/09/27/Java 基础(一)/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-10-20T09:46:01.124Z</updated>
    
    <content type="html"><![CDATA[<center>    Java 基础（一）</center><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><table><thead><tr><th align="center">类型名</th><th align="center">取值范围</th><th align="center">占用内存空间字节</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">-2^7~2^(7-1)</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">-2^15~2^(15-1)</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">-2^31~2^(31-1)</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">-2^63~2^(63-1)</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">1.4E-45 ~ 3.4E+38<br>-3.4E+38 ~ -1.4E-45</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">4.9E-324 ~ 1.7E+308<br>-1.7E+308 ~ -4.9E-324</td><td align="center">8</td></tr><tr><td align="center">boolean</td><td align="center">ture false</td><td align="center">具体情况而定</td></tr><tr><td align="center">char</td><td align="center"></td><td align="center">2</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>变量就是给数据取名字，方便找不同的数据，它的值可以变，但是含义不应变。</p></blockquote><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><blockquote><p>基本类型的数组有三种赋值方式</p><ul><li>int[] arr = {1,2,3};</li><li>int[] arr = new int[]{1,2,3};</li><li>int[] arr = new int[3];<br>arr[0]=1; arr[1]=2;arr[2]=3;</li></ul></blockquote><blockquote><p>数组类型有两块内存空间</p><ul><li>一块是存储数组内容本身；</li><li>另一块是存储数组内容的位置；<blockquote><p>数组和对象类型，内容空间一般分配在堆上，而存放地址的空间分配在栈；</p><blockquote><p>栈：</p><p>堆：</p></blockquote></blockquote></li></ul></blockquote><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><table><thead><tr><th align="center">运算符</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">加</td><td align="center">+</td></tr><tr><td align="center">减</td><td align="center">-</td></tr><tr><td align="center">乘</td><td align="center">*</td></tr><tr><td align="center">除</td><td align="center">/</td></tr><tr><td align="center">取模</td><td align="center">%</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的组成"><a href="#函数的组成" class="headerlink" title="函数的组成"></a>函数的组成</h3><ul><li>函数名字</li><li>参数</li><li>操作</li><li>返回值</li></ul><h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main函数表示程序的入口<br>同一个类中函数名相同但参数不同的现象，一般称为函数重载。</p></blockquote><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><blockquote><p>调用自己的函数称为递归函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      基础的数据类型
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础(三)</title>
    <link href="http://yoursite.com/2019/09/27/Java%20%E5%9F%BA%E7%A1%80(%E4%B8%89)/"/>
    <id>http://yoursite.com/2019/09/27/Java 基础(三)/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-11-06T15:02:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遍历数组的几种方式"><a href="#遍历数组的几种方式" class="headerlink" title="遍历数组的几种方式"></a>遍历数组的几种方式</h1><ul><li><p>方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] str  = &#123;<span class="string">"185****2662"</span>,<span class="string">"150****1342"</span>,<span class="string">"185****2662"</span>,<span class="string">"150****1342"</span>,<span class="string">"157****8935"</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; str.length; i++ ) &#123;</span><br><span class="line">    System.out.println(str[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] str  = &#123;<span class="string">"185****2662"</span>,<span class="string">"150****1342"</span>,<span class="string">"185****2662"</span>,<span class="string">"150****1342"</span>,<span class="string">"157****8935"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String number : str ) &#123;</span><br><span class="line">      System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>美剧</title>
    <link href="http://yoursite.com/2019/09/27/%E7%BE%8E%E5%89%A7%E6%8E%A8%E8%8D%90/"/>
    <id>http://yoursite.com/2019/09/27/美剧推荐/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-11-05T15:25:23.237Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Modern Family</li><li>How I Met Your Mother</li><li>The Ellen Show</li><li>Conan</li><li>James Corden</li><li>The Graham Norton Show</li><li>Brooklyn 99</li><li>Scrubs</li><li>Silicon Valley</li><li>Heabag</li></ol>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="英语学习" scheme="http://yoursite.com/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="美剧" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown</title>
    <link href="http://yoursite.com/2019/09/27/markdown%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/09/27/markdown学习指南/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-10-08T06:41:25.550Z</updated>
    
    <content type="html"><![CDATA[<center>MarkDown学习指南</center># MarkDown 标题<ol><li>使用=和-标记一级和二级标题</li></ol><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="我展示的二级标题"><a href="#我展示的二级标题" class="headerlink" title="我展示的二级标题"></a>我展示的二级标题</h2><h1 id="我也是一级标题"><a href="#我也是一级标题" class="headerlink" title="我也是一级标题"></a>我也是一级标题</h1><h2 id="我也是二级标题"><a href="#我也是二级标题" class="headerlink" title="我也是二级标题"></a>我也是二级标题</h2><h1 id="MarkDown-字体"><a href="#MarkDown-字体" class="headerlink" title="MarkDown 字体"></a>MarkDown 字体</h1><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><strong><em>粗斜体文本</em></strong></p><p><strong><em>粗斜体文本</em></strong></p><h1 id="MarkDown-分割线"><a href="#MarkDown-分割线" class="headerlink" title="MarkDown 分割线"></a>MarkDown 分割线</h1><hr><hr><hr><hr><hr><h1 id="MarkDown-删除线"><a href="#MarkDown-删除线" class="headerlink" title="MarkDown 删除线"></a>MarkDown 删除线</h1><p><del>~ 我删除了 ~</del></p><h1 id="MarkDown-脚注"><a href="#MarkDown-脚注" class="headerlink" title="MarkDown 脚注"></a>MarkDown 脚注</h1><h3 id="无序列表-使用-“-”-”-“-”-”"><a href="#无序列表-使用-“-”-”-“-”-”" class="headerlink" title="无序列表 使用(“*”,”-“,”+”)"></a>无序列表 使用(“*”,”-“,”+”)</h3><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>第一项：<ul><li>第一项的第一个元素</li><li>第一项的第二个元素</li></ul></li><li>第二项：<ul><li>第二项的第一个元素</li><li>第二项的第二个元素</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><h3 id="Markdown-区块引用是在段落的开头使用-gt-符号，然后在后面紧跟着一个空格符号："><a href="#Markdown-区块引用是在段落的开头使用-gt-符号，然后在后面紧跟着一个空格符号：" class="headerlink" title="Markdown 区块引用是在段落的开头使用&gt;符号，然后在后面紧跟着一个空格符号："></a>Markdown 区块引用是在段落的开头使用&gt;符号，然后在后面紧跟着一个空格符号：</h3><h4 id="简单区块"><a href="#简单区块" class="headerlink" title="简单区块"></a>简单区块</h4><blockquote><p>区块内容一<br>区块内容二<br>区块内容三</p></blockquote><h4 id="嵌套区块"><a href="#嵌套区块" class="headerlink" title="嵌套区块"></a>嵌套区块</h4><pre><code>&gt; 最外层区块&gt; &gt; 第一层区块&gt; &gt; &gt; 第二层区块</code></pre><h4 id="区块和列表-嵌套使用"><a href="#区块和列表-嵌套使用" class="headerlink" title="区块和列表 嵌套使用"></a>区块和列表 嵌套使用</h4><h5 id="区块内嵌套列表"><a href="#区块内嵌套列表" class="headerlink" title="区块内嵌套列表"></a>区块内嵌套列表</h5><pre><code>&gt; 区块&gt; 1. 第一项&gt; 2. 第二项</code></pre><h5 id="列表内嵌套区块"><a href="#列表内嵌套区块" class="headerlink" title="列表内嵌套区块"></a>列表内嵌套区块</h5><ul><li><p>第一项</p><blockquote><p>区块内容一<br>区块内容二</p></blockquote></li><li><p>第二项</p><blockquote><p>区块内容一<br>区块内容二</p></blockquote></li></ul><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(<span class="string">"我是代码"</span>)</span><br></pre></td></tr></table></figure><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><h3 id="链接方式一"><a href="#链接方式一" class="headerlink" title="链接方式一"></a>链接方式一</h3><p>我是一个链接<a href="https://maojingsong.com" target="_blank" rel="noopener">代码老司机</a></p><h3 id="链接方式二"><a href="#链接方式二" class="headerlink" title="链接方式二"></a>链接方式二</h3><p><a href="https://maojingsong.com" target="_blank" rel="noopener">https://maojingsong.com</a></p><h3 id="高级链接-链接也可以用变量来代替，文档末尾附带变量地址："><a href="#高级链接-链接也可以用变量来代替，文档末尾附带变量地址：" class="headerlink" title="高级链接 链接也可以用变量来代替，文档末尾附带变量地址："></a>高级链接 链接也可以用变量来代替，文档末尾附带变量地址：</h3><p>这是一个高级链接<a href="https://maojingsong.com" target="_blank" rel="noopener">代码老司机</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="代码老中医"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><table><thead><tr><th>天气</th><th>日期</th></tr></thead><tbody><tr><td>晴天</td><td>20191004</td></tr><tr><td>阴天</td><td>20191005</td></tr></tbody></table><table><thead><tr><th align="left">天气</th><th align="center">日期</th><th align="right">任务</th></tr></thead><tbody><tr><td align="left">晴天</td><td align="center">20191004</td><td align="right">学习</td></tr><tr><td align="left">阴天</td><td align="center">20191005</td><td align="right">学习</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="编程习惯" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF/"/>
    
    
      <category term="编程习惯" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>程序员准则</title>
    <link href="http://yoursite.com/2019/09/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%87%86%E5%88%99/"/>
    <id>http://yoursite.com/2019/09/27/程序员准则/</id>
    <published>2019-09-27T13:13:50.000Z</published>
    <updated>2019-10-25T12:22:10.617Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>我不会产生有害的代码。</p></li><li><p>我制作的代码永远是我最好的作品。我不会故意允许在行为或结构上有缺陷的代码。</p></li><li><p>每次发布时，我都会生成一个快速、可靠、可重复的证据，证明代码的每个元素都应该正常工作。</p></li><li><p>我将经常发布小版本，这样我就不会妨碍其他人的进展。</p></li><li><p>我会抓住每一个机会，无畏地，不懈地改进我的代码。我永远不会损害它们。</p></li><li><p>我将尽我所能保持自己和他人的生产力。我不会做任何降低生产力的事情。</p></li><li><p>我将继续确保支持其他人的工作，并且他们也可以支持我的工作。</p></li><li><p>我将对幅度和精度做出诚实的估计。我不会作出做不到的诺言。</p></li><li><p>我将永远不会停止学习和改进我的手艺。</p></li></ul>]]></content>
    
    <summary type="html">
    
      相信习惯的力量
    
    </summary>
    
    
      <category term="程序员那些事" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="准则" scheme="http://yoursite.com/tags/%E5%87%86%E5%88%99/"/>
    
  </entry>
  
</feed>
